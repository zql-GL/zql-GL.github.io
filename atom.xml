<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤寡杂货铺</title>
  
  <subtitle>学习资料库</subtitle>
  <link href="https://zql-gl.github.io/atom.xml" rel="self"/>
  
  <link href="https://zql-gl.github.io/"/>
  <updated>2022-10-26T15:01:01.506Z</updated>
  <id>https://zql-gl.github.io/</id>
  
  <author>
    <name>从未</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web知识</title>
    <link href="https://zql-gl.github.io/posts/6.html"/>
    <id>https://zql-gl.github.io/posts/6.html</id>
    <published>2022-10-26T15:00:00.000Z</published>
    <updated>2022-10-26T15:01:01.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web测试笔记"><a href="#Web测试笔记" class="headerlink" title="Web测试笔记"></a>Web测试笔记</h1><h2 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>C/S：客服端-服务端</li><li>B/S：浏览器端-服务端</li><li>P2P：点对点</li></ul><h3 id="web-url-的组成"><a href="#web-url-的组成" class="headerlink" title="web url 的组成"></a>web url 的组成</h3><ul><li>协议类型：如:http或https</li><li>主机名：域名或IP</li><li>端口号：0~65535（http默认端口80，https默认443）</li><li>页面文件或路径</li><li>附加部分：查询参数，在？后面，名字=值 的形式  多个参数使用&amp;符号间隔</li></ul><h2 id="HTML语言"><a href="#HTML语言" class="headerlink" title="HTML语言"></a>HTML语言</h2><h3 id="改变字体、字号、颜色的语句：文字"><a href="#改变字体、字号、颜色的语句：文字" class="headerlink" title="改变字体、字号、颜色的语句：文字"></a>改变字体、字号、颜色的语句：<font color="颜色" size="大小(1~7)" face="字体">文字</font></h3><h3 id="加粗：-下划线：-斜体字：-标题：-…"><a href="#加粗：-下划线：-斜体字：-标题：-…" class="headerlink" title="加粗：  下划线：   斜体字：  标题：,…"></a>加粗：<b></b>  下划线：<u></u>   斜体字：<i></i>  标题：</h3><h1></h1>,<h3></h3>…<h6></h6><h3 id="快捷键：ctrl-shift-Q这是多行注释-ctrl-shift-K和CTRL-Z这2个是整行还原注释-注释："><a href="#快捷键：ctrl-shift-Q这是多行注释-ctrl-shift-K和CTRL-Z这2个是整行还原注释-注释：" class="headerlink" title="快捷键：ctrl+shift+Q这是多行注释 ctrl+shift+K和CTRL+Z这2个是整行还原注释  注释："></a>快捷键：ctrl+shift+Q这是多行注释 ctrl+shift+K和CTRL+Z这2个是整行还原注释  注释：<!--内容--></h3><h3 id="用于添加横线-用于在网页上添加横线"><a href="#用于添加横线-用于在网页上添加横线" class="headerlink" title=" 用于添加横线   :用于在网页上添加横线"></a><hr> 用于添加横线   <hr color="“颜色”" width="大小" align="‘左、中、右’">:用于在网页上添加横线</h3><h3 id="框架：-框架可嵌套，里面没有标签-属性有cols按列划分；rows按行划分-在HTML5中使用标签，它包含在中-去掉边框是-frameborder-‘0’"><a href="#框架：-框架可嵌套，里面没有标签-属性有cols按列划分；rows按行划分-在HTML5中使用标签，它包含在中-去掉边框是-frameborder-‘0’" class="headerlink" title="框架： 框架可嵌套，里面没有标签  属性有cols按列划分；rows按行划分  在HTML5中使用标签，它包含在中 去掉边框是 frameborder=‘0’"></a>框架： 框架可嵌套，里面没有标签  属性有cols按列划分；rows按行划分  在HTML5中使用<iframe></iframe>标签，它包含在中 去掉边框是 frameborder=‘0’</h3><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>无序列表：<ul></ul></li><li>有序列表：<ol></ol></li><li>列表项：</li><li></li> 包含在列表内</ul><h3 id="分段与换行：：分段-换行"><a href="#分段与换行：：分段-换行" class="headerlink" title="分段与换行：：分段  :换行"></a>分段与换行：<p></p>：分段  <br>:换行</h3><h3 id="分块：-标签-对网页进行分块布局"><a href="#分块：-标签-对网页进行分块布局" class="headerlink" title="分块： 标签  对网页进行分块布局"></a>分块：<div></div> 标签  对网页进行分块布局</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="图片地址" alt="‘替代文本’" height="‘像素’" width="‘像素’"></h3><h3 id="表格：-行数列数-border-属性定义边框宽度-：用于定义表格的标题"><a href="#表格：-行数列数-border-属性定义边框宽度-：用于定义表格的标题" class="headerlink" title="表格： 行数列数   border 属性定义边框宽度  ：用于定义表格的标题"></a>表格：<table> <tbody><tr><td>行数列数</td></tr></tbody></table>   border 属性定义边框宽度  ：用于定义表格的标题</h3><h3 id="超链接：字体、图片-target-’-blank’-表示点击后新开一个标签页打开网址"><a href="#超链接：字体、图片-target-’-blank’-表示点击后新开一个标签页打开网址" class="headerlink" title="超链接：字体、图片   target=’_blank’ 表示点击后新开一个标签页打开网址"></a>超链接：<a href="目标地址" target="_blank">字体、图片</a>   target=’_blank’ 表示点击后新开一个标签页打开网址</h3><h3 id="转义字符：-空格-lt-gt-nbsp-lt-小于号-lt-gt-lt-gt-大于号-lt-gt-gt-amp-lt-gt-amp-“-双引号-lt-gt-quot"><a href="#转义字符：-空格-lt-gt-nbsp-lt-小于号-lt-gt-lt-gt-大于号-lt-gt-gt-amp-lt-gt-amp-“-双引号-lt-gt-quot" class="headerlink" title="转义字符：  空格<==>&nbsp;  < (小于号)<==><  >(大于号)<==>>  &amp; <==>&amp;     “(双引号)<==>&quot;"></a>转义字符：  空格&lt;==&gt;&nbsp;  &lt; (小于号)&lt;==&gt;&lt;  &gt;(大于号)&lt;==&gt;&gt;  &amp; &lt;==&gt;&amp;     “(双引号)&lt;==&gt;"</h3><h3 id="表单："><a href="#表单：" class="headerlink" title="表单："></a>表单：<form></form></h3><h3 id="视频-音频"><a href="#视频-音频" class="headerlink" title="视频/音频"></a>视频/音频</h3><ul><li><video>:在页面中播放视频 <video src="地址" controls="controls"></video></video></li><li><audio>:用于在页面上播放音频  <audio src="地址" controls="controls"></audio></audio></li></ul><h3 id="DOM-文件对象模型-控制网页的呈现方式"><a href="#DOM-文件对象模型-控制网页的呈现方式" class="headerlink" title="DOM:文件对象模型  控制网页的呈现方式"></a>DOM:文件对象模型  控制网页的呈现方式</h3><h2 id="CSS语言"><a href="#CSS语言" class="headerlink" title="CSS语言"></a>CSS语言</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>用于布局与美化网页</li><li>大小写不敏感</li><li>可以让内容（html）和样式（css）分离，方便维护</li></ul><h3 id="三种存在形式"><a href="#三种存在形式" class="headerlink" title="三种存在形式"></a>三种存在形式</h3><ul><li><p>行间样式</p><ul><li>在HTML某个标签的属性中指定style属性，指定其样式</li></ul></li><li><p>内部样式</p><ul><li>在HTML页面的头部中用<style>标签写入当前页面的样式</li></ul></li><li><p>外部样式</p><ul><li>CSS被定义成单独的外部文件，以.css结尾。在<head></head>中用<link>标签指定css文件的位置</li></ul></li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li>h1{属性:值;属性:值;}</li></ul><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul><li><p>元素选择器</p></li><li><p>派生选择器（后代或子代选择器）</p><ul><li>使用 空格 隔开，只要是后代都会应用样式</li><li>使用 &gt; 号 ，只有儿子才会应用样式</li></ul></li><li><p>id选择器</p><ul><li>用 # 号来定义 ，可以和派生选择器组合使用</li></ul></li><li><p>类选择器</p><ul><li>以一个点号 . 显示。寻找有class属性对应值的标签，也可以和派生选择器一起使用</li></ul></li><li><p>属性选择器</p><ul><li>[属性名=值]{样式}   属性第一个字符不能使用数字 *= 是模糊匹配</li></ul></li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul><li>行间样式 &gt; 选择器样式（内部样式或外部样式）</li><li>id选择器 &gt; 类选择器 = 属性选择器 &gt; 元素选择器 &gt; 继承自父类标签的样式</li><li>相同选择器等级的情况下：距离标签越近的样式越优先</li></ul><h2 id="JavaScript语言"><a href="#JavaScript语言" class="headerlink" title="JavaScript语言"></a>JavaScript语言</h2><h3 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h3><ul><li>document.write()</li></ul><h3 id="onclick-鼠标点击元素后执行里面的JavaScript代码"><a href="#onclick-鼠标点击元素后执行里面的JavaScript代码" class="headerlink" title="onclick:鼠标点击元素后执行里面的JavaScript代码"></a>onclick:鼠标点击元素后执行里面的JavaScript代码</h3><h3 id="alert-函数：弹框提示信息"><a href="#alert-函数：弹框提示信息" class="headerlink" title="alert()函数：弹框提示信息"></a>alert()函数：弹框提示信息</h3><h3 id="document-getElementById-‘标签的id值’-：通过id属性找到对应的标签元素"><a href="#document-getElementById-‘标签的id值’-：通过id属性找到对应的标签元素" class="headerlink" title="document.getElementById(‘标签的id值’)：通过id属性找到对应的标签元素"></a>document.getElementById(‘标签的id值’)：通过id属性找到对应的标签元素</h3><h3 id="innerHTML：改变标签中的内容"><a href="#innerHTML：改变标签中的内容" class="headerlink" title="innerHTML：改变标签中的内容"></a>innerHTML：改变标签中的内容</h3><h3 id="isNaN-验证是否输入数字"><a href="#isNaN-验证是否输入数字" class="headerlink" title="isNaN():验证是否输入数字"></a>isNaN():验证是否输入数字</h3><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="服务端技术"><a href="#服务端技术" class="headerlink" title="服务端技术"></a>服务端技术</h3><ul><li><p>web服务器</p><ul><li><p>apache</p><ul><li>httpd</li></ul></li><li><p>nginx</p><ul><li>反向代理</li></ul></li><li><p>lls</p></li><li><p>lighttpd</p></li></ul></li><li><p>应用服务器</p><ul><li>Tomcat</li><li>Jetty</li><li>Jboss</li><li>websphere</li><li>weblogic</li><li>lls</li></ul></li></ul><h3 id="客服端技术"><a href="#客服端技术" class="headerlink" title="客服端技术"></a>客服端技术</h3><ul><li><p>渲染引擎</p><ul><li><p>Trident</p><ul><li>IE</li></ul></li><li><p>gecko</p><ul><li>firefox</li></ul></li><li><p>webkit</p><ul><li>safari</li></ul></li><li><p>Blink</p><ul><li>chrome</li><li>新版Opera</li><li>新版edge</li></ul></li></ul></li><li><p>JavaScript引擎</p><ul><li><p>Chakra</p><ul><li>IE9/10/11,Edge</li></ul></li><li><p>JScript</p><ul><li>IE8及以下</li></ul></li><li><p>Monkey系列</p><ul><li>Firefox</li></ul></li><li><p>V8</p><ul><li>chrome</li><li>新版Opera</li></ul></li><li><p>Nitro</p><ul><li>safari</li></ul></li></ul></li><li><p>web网络协议</p><ul><li><p>网络协议模型</p><ul><li><p>OSI模型</p><ul><li><p>1 物理层</p><ul><li>建立物理连接，传输物理信号  比特（bit） 网线、光纤、无线</li></ul></li><li><p>2 链路层</p><ul><li>通过MAC地址（物理地址）找到对应的计算机，传输数据  帧（frame） 交换机</li></ul></li><li><p>3 网络层</p><ul><li>通过IP地址找到对应的计算机  数据包（packet）  路由器</li></ul></li><li><p>4 传输层</p><ul><li>通过端口号找到对应的程序，并且控制传输过程  数据段（segment） TCP协议</li></ul></li><li><p>5 会话层</p><ul><li>管理是否允许两台电脑进行连接。连接中断后，是否重新连接</li></ul></li><li><p>6 表示层</p><ul><li>数据编码、加密解密、压缩</li></ul></li><li><p>7 应用层</p><ul><li>HTTP浏览网页、FTP传文件等</li></ul></li></ul></li><li><p>TCP/IP模型</p><ul><li><p>1 网络访问层</p><ul><li>物理层</li><li>链路层</li></ul></li><li><p>2 Internet层</p><ul><li>网络层</li></ul></li><li><p>3 传输层</p><ul><li>传输层</li></ul></li><li><p>4 应用层</p><ul><li>会话层</li><li>表示层</li><li>应用层</li></ul></li></ul></li><li><p>IP（Internet Protocol）协议</p><ul><li><p>IPv4  32位长度</p></li><li><p>IPv6  128位长度</p></li><li><p>子网掩码：将IP地址分割成网络地址和主机地址，子网掩码中255对应的就是网络地址，子网掩码中 0对应的就是主机地址</p></li><li><p>分类</p><ul><li><p>A类：（1.0.0.1 - 16.255.255.254）（默认子网掩码：255.0.0.0)</p></li><li><p>B类：（128.0.0.1 - 191.255.255.254）（默认子网掩码：255.255.0.0）</p></li><li><p>C类：（192.0.0.1 - 223.255.255.254）（子网掩码：255.255.255.0）</p></li><li><p>D类：（224.0.0.1 - 239.255.255.254）是多点广播地址，无子网掩码</p></li><li><p>E类：（240.0.0.0 - 255.255.255.254）保留地址，未被使用</p></li><li><p>一些特殊的IP地址</p><ul><li>10.0.0.0 - 10.255.255.255  A类的私有地址（不能外网使用，只能内网使用）</li><li>172.16.0.0 - 172.31.255.255 B类的私有地址（不能外网使用，只能内网使用）</li><li>192.168.0.0 - 192.168.255.255 C类的私有地址（不能外网使用，只能内网使用）</li><li>127.0.0.1 表示本机   =localhost</li></ul></li></ul></li></ul></li><li><p>TCP协议</p><ul><li>建立TCP需要三次握手才能建立，断开连接则需要四次挥手</li></ul></li><li><p>HTTP协议</p><ul><li><p>请求 - 应答式的协议</p></li><li><p>HTTP请求</p><ul><li><p>组成</p><ul><li>请求行（request line）</li><li>请求头（header）</li><li>请求体（body）</li></ul></li><li><p>方法</p><ul><li>get请求：主要是数据的获取</li><li>post请求：主要是数据的提交</li><li>head请求：类似get请求，只不过响应中只有header部分，没有body部分</li><li>put请求：从客服端向服务器传送的数据 替换 指定的文档的内容</li><li>delete请求：指明客服端想让服务器删除某个资源文件</li><li>options请求：客服端询问服务器可以提交哪些请求方法</li><li>trace请求：客服端可以对请求消息的传输路径进行追踪</li><li>connect请求：要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信</li></ul></li></ul></li><li><p>HTTP响应</p><ul><li>状态行（status line）</li><li>消息报头（header）</li><li>响应正文（response-body）</li></ul></li><li><p>cookie</p><ul><li>服务器通过set-cookie让浏览器保存的键值对信息，浏览器每次访问服务器都必须把cookie值发送回服务器。</li></ul></li><li><p>session</p><ul><li>用户访问网站或登录后，服务器会针对本次会话存放一些用户的信息到一个session文件。然后发送sessionid给用户浏览器。浏览器下一次发送请求给服务器时，服务器通过收到的sessionid就能知道是哪个用户在访问了。</li></ul></li><li><p>token</p><ul><li>用户访问网站或登录后，服务器会针对用户ID生成一个加密字符串，这个就是token。把这个token发送给用户浏览器。浏览器下一次发送请求给服务器，服务器通过收到的token值就能知道是哪个用户在访问了。</li></ul></li></ul></li></ul></li></ul></li></ul></style></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Web测试笔记&quot;&gt;&lt;a href=&quot;#Web测试笔记&quot; class=&quot;headerlink&quot; title=&quot;Web测试笔记&quot;&gt;&lt;/a&gt;Web测试笔记&lt;/h1&gt;&lt;h2 id=&quot;网络架构&quot;&gt;&lt;a href=&quot;#网络架构&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="知识文档" scheme="https://zql-gl.github.io/tags/%E7%9F%A5%E8%AF%86%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象</title>
    <link href="https://zql-gl.github.io/posts/3.html"/>
    <id>https://zql-gl.github.io/posts/3.html</id>
    <published>2022-10-23T15:00:00.000Z</published>
    <updated>2022-10-23T11:43:04.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="三个基本特性"><a href="#三个基本特性" class="headerlink" title="三个基本特性"></a>三个基本特性</h3><ul><li><p>封装</p><ul><li>封装能够使外部访问者不能随意存取对象的内部<br>数据，隐藏了对象的内部细节，只保留有限的对外接口。外部访问者不用关心对象的内部细节，使得操作对象变得简单</li></ul></li><li><p>继承</p><ul><li>在Java语言中一般类称为“父类”，特殊类称为“子类”。Java语言是单继承的，即只能有一个父类，但Java可以实现多个接口，可以防止多继承所引起的冲突问题</li></ul></li><li><p>多态</p><ul><li>多态性是指在父类中成员变量和成员方法被子类继承之后，可以具有不同的状态或表现行为</li></ul></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li><p>类是Java中的一种重要的引用数据类型，是组成Java程序的基本要素。它封装了一类对象的数据和操作。</p></li><li><p>Java语言中一个类的实现包括：类声明和类体。类声明语法格式如下：<br>[public][abstract|final] class className [extends superclassName] [implements interfaceNameList] {<br>//类体<br>}</p><ul><li>class是声明类的关键字，className是自定义的类名；class前面的修饰符public、abstract、final用来声明类，它们可以省略，它们的具体用法后面章节会详细介绍；superclassName为父类名，可以省略，如果省略则该类继承Object类，Object类所有类的根类，所有类都直接或间接继承Object；interfaceNameList是该类实现的接口列表，可以省略，接口列表中的多个接口之间用逗号分隔</li><li>类体是类的主体，包括数据和操作，即成员变量和成员方法。</li></ul></li><li><p>成员变量</p><ul><li>声明类体中成员变量语法格式如下：<br>class className {<br>[public | protected | private ] [static] [final] type variableName; //成员变量<br>}</li></ul></li></ul><pre><code>    - type是成员变量数据类型，variableName是成员变量名。type前的关键字都是成员变量修饰符，它们说明如下：    - 01. public、protected和private修饰符用于封装成员变量。    - 02. static修饰符用于声明静态变量，所以静态变量也称为“类变量”。    - 03. final修饰符用于声明变量，该变量不能被修改</code></pre><ul><li><p>成员方法</p><ul><li>声明类体中成员方法语法格式如下：class className {<br>[public | protected | private ] [static] [final | abstract] [native] [synchronized]<br>type methodName([paramList]) [throws exceptionList] {<br>//方法体<br>}<br>}</li></ul></li></ul><pre><code>    - type是方法返回值数据类型，methodName是方法名。type前的关键字都是方法修饰符，它们说明如下：    - 01. public、protected和private修饰符用于封装方法。    - 02. static修饰符用于声明静态方法，所以静态方法也称为“类方法”。    - 03. final | abstract不能同时修饰方法，final修饰的方法不能在子类中被覆盖；abstract用来修饰抽象方法，抽象方法必须在子类中被实现。    - 04. native修饰的方法，称为“本地方法”，本地方法调用平台本地代码（如：C或C++编写的代</code></pre><p>码），不能实现跨平台。<br>        - 05. synchronized修饰的方法是同步的，当多线程方式同步方法时，只能串行地执行，保证是线程安全的。<br>        - 06.方法声明中还有([paramList])部分，它是方法的参数列表。throws exceptionList是声明抛出异常列表。</p><pre><code>- 如果方法返回值类型为void时，方法体包含“return;”语句，如果“return;”语句是最后一行则可以省略。通常return语句通常用在一个方法体的最后，否则会产生编译错误，除非用在if-else语句</code></pre><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul><li><p>作用</p><ul><li>在Java中为了防止类、接口、枚举和注释等命名冲突引用了包（package）概念，包本质上命名空间（namespace） 。在包中可以定义一组相关的类型（类、接口、枚举和注释），并为它们提供访问保护和命名空间管理。</li></ul></li><li><p>包定义</p><ul><li>Java中使用package语句定义包，package语句应该放在源文件的第一行，在每个源文件中只能有一个包定义语句，并且package语句适用于所有类型（类、接口、枚举和注释）的文件。定义包语法格式如下：packagepkg1[.pkg2[.pkg3…]];</li></ul></li><li><p>包引入</p><ul><li>使用import语句实现引入包，import语句应位于package语句之后，所有类的定义之前，可以有0~n条import语句，其语法格式为：import package1[.package2…].(类型名|*);</li><li>“包名.类型名”形式只引入具体类型，“包名.*”采用通配符，表示引入这个包下所有的类型。</li></ul></li><li><p>常用包</p><ul><li><p>Java SE提供一些常用包，其中包含了Java开发中常用的基础类。这些包有：java.lang、java.io、java.net、java.util、java.text、java.awt和javax.swing。</p></li><li><ol><li>java.lang包</li></ol><ul><li>java.lang包含中包含了Java语言的核心类，如Object、Class、String、包装类和Math等，还有包装类Boolean、Character、Integer、Long、Float和Double。使用java.lang包中的类型，不需要显示使用import语句引入，它是由解释器自动引入。</li></ul></li><li><ol start="2"><li>java.io包</li></ol><ul><li>java.io包含中提供多种输入/输出流类，如InputStream、OutputStream、Reader和Writer。还有文件管理相关类和接口，如File和FileDescriptor类以及FileFilter接口。</li></ul></li><li><ol start="3"><li>java.net包</li></ol><ul><li>java.net包含进行网络相关的操作的类，如URL、Socket和ServerSocket等。</li></ul></li><li><ol start="4"><li>java.util包</li></ol><ul><li>java.util包含一些实用工具类和接口，如集合、日期和日历相关类和接口。</li></ul></li><li><ol start="5"><li>java.text包</li></ol><ul><li>java.text包中提供文本处理、日期式化和数字格式化等相关类和接口。</li></ul></li><li><ol start="6"><li>java.awt和javax.swing包</li></ol><ul><li>java.awt和javax.swing包提供了Java图形用户界面开发所需要的各种类和接口。java.awt提供是一些基础类和接口，javax.swing提供了一些高级组件。</li></ul></li></ul></li></ul><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><ul><li>在设计一个类时将具有相似功能的方法起相同的名字。方法重载中参数列表不同的含义是：参数的个数不同或者是参数类型不同</li><li>这些相同名字的方法之所以能够在一个类中同时存在，是因为它们的方法参数列表，调用时根据参数列表调用相应重载方法</li></ul><h3 id="封装性与访问控制"><a href="#封装性与访问控制" class="headerlink" title="封装性与访问控制"></a>封装性与访问控制</h3><ul><li><p>访问控制修饰符 : default, public , protected, private</p><ul><li>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</li><li>default (默认级别）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>private （私有级别）: 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。</li><li>public（公有级别） : 对所有类可见。使用对象：类、接口、变量、方法</li><li>protected （保护级别）: 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）基类的 protected 成员是包内可见的，并且对子类可见；若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。</li></ul></li><li><p>非访问控制修饰符 : final, abstract, static, synchronized</p><ul><li><p>static 修饰符，用来修饰类方法和类变量。</p><ul><li>静态变量：static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</li><li>静态方法：static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</li><li>对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。</li></ul></li><li><p>final 修饰符，用来修饰类、方法和变量</p><ul><li>final 修饰的类不能够被继承，父类中的 final 方法可以被子类继承，但是不能被子类重写。修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li></ul></li><li><p>abstract 修饰符，用来创建抽象类和抽象方法。</p><ul><li>抽象类：抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。抽象类可以包含抽象方法和非抽象方法。</li><li>抽象方法：抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。抽象方法不能被声明成 final 和 static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。抽象方法的声明以分号结尾，例如：public abstract sample();。</li></ul></li><li><p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p><ul><li>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</li><li>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</li><li>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个 volatile 对象引用可能是 null</li></ul></li></ul></li><li><p>访问控制和继承</p><ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li><li>父类中声明为 private 的方法，不能够被子类继承。</li></ul></li><li><p>访问类成员</p><ul><li><p>访问成员有两种方式：一种是调用，即通过类或对象调用它的成员，如p.printX()语句；另<br>一种是继承，即子类继承父类的成员变量和方法</p><ul><li>公有访问级别任何情况下两种方式都可以；</li><li>默认访问级别在同一包中两种访问方式都可以，不能在包之外访问；</li><li>保护访问级别在同一包中与默认访问级别一样，两种访问方式都可以。但是在不同包之外只能继承访问；</li><li>私有访问级别只能在本类中通过调用方法访问，不能继承访问。</li></ul></li><li><p>访问类成员时，在能满足使用的前提下，应尽量限制类中成员的可见性，访问级别顺序是：私有级别→默认级别→保护级别→公有级别。</p></li></ul></li></ul><h3 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h3><ul><li>static修饰的成员变量是静态变量，staitc修饰的方法是静态方法，没有static修饰的成员变量是实例变量，没有staitc修饰的方法是实例方法，</li><li>静态方法可以访问静态变量和其他静态方法，实例方法可以访问实例变量、其他实例方法、静态变量和静态方法</li></ul><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><ul><li>静态变量可以在声明的同时初始化，如果初始化静态变量不是简单常量，需要进行计算才能初始化，可以使用静态（static）代码块，静态代码块在类第一次加载时执行，并只执行一次</li><li>在静态代码块中可以初始化静态变量，也可以调用静态方法。</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul><li><p>类实例化可生成对象，实例方法就是对象方法，实例变量就是对象属性。一个对象的生命周期包括三个阶段：创建、使用和销毁；创建对象包括两个步骤：声明和实例化。</p></li><li><ol><li>声明</li></ol><ul><li>声明对象与声明普通变量没有区别，语法格式如下：type objectName;其中type是引用类型，即类、接口和数组</li></ul></li><li><ol start="2"><li>实例化</li></ol><ul><li>实例化过程分为两个阶段：为对象分配内存空间和初始化对象，首先使用new运算符为对象分配<br>内存空间，然后再调用构造方法初始化对象。示例代码如下：String name;<br>name = new String(“Hello World”);</li></ul></li></ul><h3 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h3><ul><li>一个引用变量没有通过new分配内存空间，这个对象就是空对象，Java使用关键字null表示空对象，引用变量默认值是null。当试图调用一个空对象的实例变量或实例方法时，会抛出空指针异常NullPointerException</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>构造方法是类中特殊方法，用来初始化类的实例变量，这个就是构造方法，它在创建对象（new运算符）之后自动调用。</li><li><ol><li>构造方法名必须与类名相同。</li></ol></li><li><ol start="2"><li>构造方法没有任何返回值，包括void。</li></ol></li><li><ol start="3"><li>构造方法只能与new运算符结合使用。</li></ol></li></ul><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><ul><li><p>this指向对象本身，一个类可以通过this来获得一个代表它自身的对象变量。this使用在如下三种情况中：</p></li><li><p>调用实例变量。</p><ul><li>参数是作用域为整个方法的局部变量，为了防止局部变量与成员变量命名发生冲突，可以使用this调用成员变量</li></ul></li><li><p>调用实例方法。</p><ul><li>this也可以调用本对象的方法</li></ul></li><li><p>调用其他构造方法</p><ul><li>使用this调用其他构造方法时，this语句一定是该构造方法的第一条语句</li></ul></li></ul><h3 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h3><ul><li>对象不再使用时应该销毁，Java语言对象是由垃圾回收器（Garbage Collection）收集然后释放</li><li>垃圾回收器（Garbage Collection）的工作原理是：当一个对象的引用不存在时，认为该对象不再需要，垃圾回收器自动扫描对象的动态内存区，把没有引用的对象作为垃圾收集起来并释放。</li></ul><h2 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h2><h3 id="Java中的继承"><a href="#Java中的继承" class="headerlink" title="Java中的继承"></a>Java中的继承</h3><ul><li>继承使用的关键字是extends，extends后面的是父类，如果在类的声明中没有使用extends关键字指明其父类，则默认父类为Object类，java.lang.Object类是Java的根类，所有Java类包括数组都直接或间接继承了Object类，Object类中定义了一些有关面向对象机制的基本方法，如equals()、toString()和finalize()等方法。</li><li>在Java中，类的继承只能是单继承，而多重继承可以通过实现多个接口实现</li></ul><h3 id="调用父类构造方法"><a href="#调用父类构造方法" class="headerlink" title="调用父类构造方法"></a>调用父类构造方法</h3><ul><li><p>当子类实例化时，不仅需要初始化子类成员变量，也需要初始化父类成员变量，初始化父类成员变量需要调用父类构造方法，子类使用super关键字调用父类构造方法</p></li><li><p>super语句必须位于子类构造方法的第一行</p></li><li><p>如果构造方法没有super语句，编译器会试图调用父类默认构造方法（无参数构造方法），如果父类Person也没有默认构造方法，那么会发生编译错误。解决这个编译错误有三种办法：</p><ul><li><ol><li>在父类Person中添加默认构造方法，子类Student会隐式调用父类的默认构造方法。</li></ol></li><li><ol start="2"><li>在子类Studen构造方法添加super语句，显式调用父类构造方法，super语句必须是第一条语句。</li></ol></li><li><ol start="3"><li>在子类Studen构造方法添加this语句，显式调用当前对象其他构造方法，this语句必须是第一条语句。</li></ol></li></ul></li></ul><h3 id="成员变量隐藏和方法覆盖"><a href="#成员变量隐藏和方法覆盖" class="headerlink" title="成员变量隐藏和方法覆盖"></a>成员变量隐藏和方法覆盖</h3><ul><li><p>成员变量隐藏</p><ul><li>子类成员变量与父类一样，会屏蔽父类中的成员变量，称为“成员变量隐藏”；如果要调用父类中的x成员变量，则需要super关键字，</li></ul></li><li><p>方法的覆盖（Override）</p><ul><li><p>如果子类方法完全与父类方法相同，即：相同的方法名、相同的参数列表和相同的返回值，只是方法体不同，这称为子类覆盖（Override）父类方法。表示子类重写了父类的方法</p></li><li><p>在声明方法时添加@Override注解@Override注解不是方法覆盖必须的，它只是锦上添花，但添加@Override注解有两个好处：</p><ul><li><ol><li>提高程序的可读性。</li></ol></li><li><ol start="2"><li>编译器检查@Override注解的方法在父类中是否存在，如果不存在则报错</li></ol></li></ul></li><li><p>方法覆盖时应遵循的原则：</p><ul><li><ol><li>覆盖后的方法不能比原方法有更严格的访问控制（可以相同）。</li></ol></li><li><ol start="2"><li>覆盖后的方法不能比原方法产生更多的异常。</li></ol></li></ul></li></ul></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li><p>多态概念</p><ul><li>发生多态要有三个前提条件：</li></ul></li></ul><ol><li>继承。多态发生一定要子类和父类之间。</li><li>覆盖。子类覆盖了父类的方法。</li><li>声明的变量类型是父类类型，但实例则指向子类实例。<ul><li>多态发生时，Java虚拟机运行时根据引用变量指向的实例调用它的方法，而不是根<br>据引用变量的类型调用。</li></ul></li></ol><ul><li><p>引用类型检查</p><ul><li>有时候需要在运行时判断一个对象是否属于某个引用类型，这时可以使用instanceof运算符，instanceof运算符语法格式如下：<br>obj instanceof type      其中obj是一个对象，type是引用类型，如果obj对象是type引用类型实例则返回true，否则false。</li></ul></li><li><p>引用类型转换</p><ul><li>引用类型可以进行转换，但并不是所有的引用类型都能互相转换，只有属于同一棵继承层次树中的引用类型才可以转换</li><li>引用类型转换也是通过小括号运算符实现，类型转换有两个方向：将父类引用类型变量转换为子类类型，这种转换称为向下转（downcast）；将子类引用类型变量转换为父类类型，这种转换称为向上转型（upcast）。向下转型需要强制转换，而向上转型是自动的。</li></ul></li><li><p>final关键字</p><ul><li><p>final修饰变量</p><ul><li><p>final修饰的变量即成为常量，无论是哪种常量都只能赋值一次，但是final所修饰局部变量和成员变量有所不同。</p></li><li><ol><li>final修饰的局部变量必须使用之前被赋值一次才能使用。</li></ol></li><li><ol start="2"><li>final修饰的成员变量在声明时没有赋值的叫“空白final变量”。空白final变量必须在构造方法或静态代码块中初始化。</li></ol><ul><li>其实局部常量最好在声明的同时初始化</li><li>如果是空白final变量是实例常量，则需要在构造方法中初始化</li><li>如果是空白final变量是静态常量，则需要在静态代码块中初始化</li></ul></li></ul></li><li><p>final修饰类</p><ul><li>final修饰的类不能被继承。有时出于设计安全的目的，不想让自己编写的类被别人继承，这时可以使用final关键字修饰父类。</li></ul></li><li><p>final修饰方法</p><ul><li>final修饰的方法不能被子类覆盖。有时也是出于设计安全的目的，父类中的方法不想被别人覆盖，这是可以使用final关键字修饰父类中方法。</li></ul></li></ul></li></ul><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li><p>抽象类概念</p><ul><li>在Java中具有抽象方法的类称为“抽象类”</li><li>Java语言提供了两种类：一种是具体类；另一种是抽象子类</li><li>抽象类不能被实例化,只有具体类才能被实例化</li></ul></li><li><p>抽象类声明和是实现</p><ul><li>在Java中抽象类和抽象方法的修饰符是abstract</li><li>抽象方法中只有方法的声明，没有方法的实现，即没有大括号（{}）部分</li><li>如果一个方法被声明为抽象的，那么这个类也必须声明为抽象的。而一个抽象类中，可以有0<del>n个抽象方法，以及0</del>n具体方法</li><li>设计抽象方法目的就是让子类来实现的，否则抽象方法就没有任何意义</li></ul></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>接口概念</p><ul><li>接口中所有方法都是抽象的，而且接口可以<br>有成员变量，在接口中成员变量都静态成员变量，即省略了public static final修饰符</li><li>接口与抽象类一样都不能被实例化</li></ul></li><li><p>接口声明和实现</p><ul><li>声明：在Java中接口的声明使用的关键字是interface</li><li>实现：某个类实现接口时，要在声明时使用implements关键字，当实现多个接口之间用逗号（,）分隔。实现接口时要实现接口中声明的所有方法。</li></ul></li><li><p>接口与多继承</p><ul><li>在C++语言中一个类可以继承多个父类，但这会有潜在的风险，如果两个父类有相同的方法，那么子类将继承哪一个父类方法呢？这就是C++多继承所导致的冲突问题。</li><li>在Java中只允许继承一个类，但可实现多个接口。通过实现多个接口方式满足多继承的设计需求。如果多个接口中即便有相同方法，它们也都是抽象的，子类实现它们不会有冲突。</li></ul></li><li><p>接口继承</p><ul><li>Java语言中允许接口和接口之间继承。由于接口中的方法都是抽象方法，所以继承之后也不需要做什么，因此接口之间的继承要比类之间的继承简单的多。</li><li>事实上在接口中覆盖方法，并没有实际意义，因为它们都是抽象的，都是留给子类实现的。</li></ul></li><li><p>Java 8新特性默认方法和静态方法</p><ul><li><p>在Java 8之前Java语言中接口存在如下不足之处：</p><ul><li><ol><li>不能可选实现方法，接口的方法全部是抽象的，实现接口时必须全部实现接口中方法，哪怕是有些方法并不需要，也必须实现。</li></ol></li><li><ol start="2"><li>没有静态方法。</li></ol></li></ul></li><li><p>针对这些问题，Java 8在接口中提供了声明默认方法和静态方法的能力</p></li><li><p>接口中的默认方法类似于类中具体方法，给出了具体实现，只是方法修饰符是default。接口中静态方法类似于类中静态方法。</p></li><li><p>实现接口时接口中原有的抽象方法在实现类中必须实现。默认方法可以根据需要有选择实现（覆<br>盖）。静态方法不需要实现，实现类中不能拥有接口中的静态方法。</p></li><li><p>接口中声明的静态方法与其他实现类没<br>有任何关系，只能通过接口名调用</p></li></ul></li><li><p>抽象类与接口的区别</p><ul><li><ol><li>接口支持多继承，而抽象类（包括具体类）只能继承一个父类。</li></ol></li><li><ol start="2"><li>接口中不能有实例成员变量，接口所声明的成员变量全部是静态常量，即便是变量不加public static final修饰符也是静态常量。抽象类与普通类一样各种形式的成员变量都可以声明。</li></ol></li><li><ol start="3"><li>接口中没有包含构造方法，由于没有实例成员变量，也就不需要构造方法了。抽象类中可以有实例成员变量，也需要构造方法。</li></ol></li><li><ol start="4"><li>抽象类中可以声明抽象方法和具体方法。Java 8之前接口中只有抽象方法，而Java 8之后接口中也可以声明具体方法，具体方法通过声明默认方法实现。</li></ol></li></ul></li></ul><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><h3 id="枚举概念"><a href="#枚举概念" class="headerlink" title="枚举概念"></a>枚举概念</h3><ul><li><p>Java 5之后提供了枚举类型，Java枚举类型本质上是一种继承java.lang.Enum类，是引用数据类型，因此也称为“枚举类”。</p></li><li><p>Java中枚举类型的作用已经不仅仅是定义一组常量提高程序的可读性了，还具有如下特性：</p><ul><li><ol><li>Java枚举类型是一种类，是引用类型，具有了面向对象特性，可以添加方法和成员变量等。</li></ol></li><li><ol start="2"><li>Java枚举类型父类是java.lang.Enum，不需要显式声明。</li></ol></li><li><ol start="3"><li>Java枚举类型可以实现接口，与类实现接口类似。</li></ol></li><li><ol start="4"><li>Java枚举类型不能被继承，不存在子类。</li></ol></li></ul></li></ul><h3 id="枚举声明"><a href="#枚举声明" class="headerlink" title="枚举声明"></a>枚举声明</h3><ul><li><p>Java中是使用enum关键词声明枚举类，具体定义放在一对大括号内，枚举的语法格式如下：<br>[public] enum 枚举名 {<br>枚举常量列表<br>}    “枚举常量列表”是枚<br>举的核心，它由一组相关常量组成。</p></li><li><p>使用枚举类时，赋值过程中实例化枚举类对象，赋值表达式是“枚举类型名.枚举常量”的形式，并初始化为枚举常量</p></li><li><p>枚举类与switch语句能够很好地配合使用，case常量直接使用枚举常量，而且不需要枚举类名作为前缀，使用起来比较简洁</p></li><li><p>在switch中使用枚举类型时，switch语句中case分支语句个数应该对应枚举常量个数，不要多也不要少，当使用default时，default应该只表示等于最后一个枚举常量情况。</p></li><li><p>枚举类可以像类一样包含成员变量和成员方法，成员变量可以是实例变量也可以是静态变量，成员方法可以是实例方法，也可以是静态方法，但不能是抽象方法。</p></li><li><p>添加的其他成员的枚举类需要注意，“枚举常量列表”语句必须是枚举类中的第一行代码。而且“枚举常量列表”语句后面要加分号（;）表示语句的结束</p></li><li><p>枚举类构造方法</p><ul><li>在类中成员变量的初始化是通过构造方法实的，而在枚举类中也是通过构造方法初始化成员变量的；注意枚举类的中的构造方法只能是私有访问级别，构造方法可以省略private关键字，但它仍然是私有的构造方法。这也说明了枚举类不允许在外部创建对象。</li></ul></li></ul><h3 id="枚举常用方法"><a href="#枚举常用方法" class="headerlink" title="枚举常用方法"></a>枚举常用方法</h3><ul><li><p>所有枚举类都继承java.lang.Enum类，Enum中定义了一些枚举中常用的方法：</p><ul><li>int ordinal()：返回枚举常量的顺序。这个顺序根据枚举常量声明的顺序而定，顺序从零开始。</li><li>枚举类型[] values()：静态方法，返回一个包含全部枚举常量的数组。</li><li>枚举类型 valueOf(String str)：静态方法，str是枚举常量对应的字符串，返回一个包含枚举类型实例。</li></ul></li><li><p>在Java类引用类型进行比较时，有两种比较方法==和equals，==比较的是两个引用是否指向同一个对象，equals是比较对象内容是否相同。但是，枚举引用类型中==和equals都是一样的，<br>都是比较两个引用是否指向同一个实例，枚举类中每个枚举常量无论何时都只有一个实例。</p></li></ul><h2 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h2><h3 id="Java根类-Object"><a href="#Java根类-Object" class="headerlink" title="Java根类-Object"></a>Java根类-Object</h3><ul><li><p>Object类属于java.lang包中的类型，不需要显示使用import语句引入，它是由解释器自动引入。</p></li><li><p>Object类有很多方法，常用的几个方法：</p><ul><li>String toString()：返回该对象的字符串表示。</li><li>boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。</li></ul></li><li><p>toString()方法</p><ul><li>为了日志输出等处理方便，所有的对象都可以以文本方式表示，需要在该对象所在类中覆盖toString()方法。如果没有覆盖toString()方法，默认的字符串是“类名@对象的十六进制哈希码 ”。</li><li>使用System.out.println等输出语句可以自动调用对象的toString()方法将对象转换为字符串输出</li></ul></li><li><p>对象比较方法</p><ul><li><p>==运算符</p><ul><li>==运算符是比较两个引用变量是否指向同一个实例</li></ul></li><li><p>equals()方法</p><ul><li>equals()方法是比较两个对象的内容是否相等，通常字符串的比较，只是关心的内容是否相等。</li><li>equals()方法是继承自Object的，所有对象都可以通过equals()方法比较，问题的关键是需要指定相等的规则，就是要指定比较的是哪些属性相等，所以为了比较两个对象相等，则需要覆盖equals()方法，在该方法中指定比较规则。</li></ul></li></ul></li></ul><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><ul><li><p>范围</p><ul><li>在Java中8种基本数据类型不属于类，不具备“对象”的特征，没有成员变量和方法，不方便进行面向对象的操作。为此，Java提供包装类（Wrapper Class）来将基本数据类型包装成类，每个Java基本数据类型在java.lang包中都有一个相应的包装类，每个包装类对象封装一个基本数据类型数值。除int和char类型外，其他的类型对应规则就是第一个字母大写</li><li>包装类都是final的，不能被继承。包装类都是不可变类，类似于String类，一旦创建了对象，其内容就不可以修改</li></ul></li><li><p>类别</p><ul><li><p>数值包装类(Byte、Short、Integer、Long、Float和Double)</p><ul><li><p>相同点</p><ul><li><ol><li>构造方法类似–每一个数值包装类都有两个构造方法，以Integer为例，Integer构造方法如下：</li></ol><ul><li>Integer(int value)：通过指定一个数值构造Integer对象。</li><li>Integer(String s)：通过指定一个字符串s构造对象，s是十进制字符串表示的数值。</li></ul></li><li><ol start="2"><li>共同的父类–这6个数值包装类有一个共同的父类——Number，Number是一个抽象类，除了这6个子类还有：AtomicInteger、AtomicLong、BigDecimal和BigInteger，Number是抽象类，要求它的子类必须实现如下6个方法</li></ol><ul><li>byte byteValue()：将当前包装的对象转换为byte类型的数值。</li><li>double doubleValue()：将当前包装的对象转换为double类型的数值。</li><li>float floatValue()：将当前包装的对象转换为float类型的数值。</li><li>int intValue()：将当前包装的对象转换为int类型的数值。</li><li>long longValue()：将当前包装的对象转换为long类型的数值。</li><li>short shortValue()：将当前包装的对象转换为short类型的数值。</li></ul></li><li><ol start="3"><li>compareTo()方法</li></ol><ul><li>每一个数值包装类都有int compareTo(数值包装类对象)方法，可以进行包装对象的比较。方法返<br>回值是int，如果返回值是0，则相等；如果返回值小于0，则此对象小于参数对象；如果返回值<br>大于0，则此对象大于参数对象。</li></ul></li><li><ol start="4"><li>字符串转换为基本数据类型–每一个数值包装类都提供一些静态parseXXX()方法将字符串转换为对应的基本数据类型，以<br>Integer为例，方法定义如下：</li></ol><ul><li>static int parseInt(String s)：将字符串s转换有符号的十进制整数。</li><li>static int parseInt(String s, int radix)：将字符串s转换有符号的整数，radix是指定基数，基数用来指定进制。注意这种指定基数的方法在浮点数包装类（Double和Float）中没有的。</li></ul></li><li><ol start="5"><li>基本数据类型转换为字符串–每一个数值包装类都提供一些静态toString()方法实现将基本数据类型数值转换为字符串，以<br>Integer为例，方法定义如下：</li></ol><ul><li>static String toString(int i)：将该整数i转换为有符号的十进制表示的字符串。</li><li>static String toString(int i, int radix)：将该整数i转换为有符号的特定进制表示的字符串，radix是基数可以指定进制。注意这种指定基数的方法在浮点数包装类（Double和Float）中没有的。</li></ul></li></ul></li></ul></li><li><p>Character</p><ul><li><p>Character类是char类型的包装类。Character类常用方法如下：</p><ul><li>Character(char value)：构造方法，通过char值创建一个新的Character对象。</li><li>char charValue()：返回此Character对象的值。</li><li>int compareTo(Character anotherCharacter)：方法返回值是int，如果返回值是0，则相等；如果返<br>回值小于0，则此对象小于参数对象；如果返回值大于0，则此对象大于参数对象。</li></ul></li></ul></li><li><p>Boolean</p><ul><li><p>01.构造方法Boolean类是boolean类型的包装类。Boolean类有两个构造方法，构造方法定义如下：</p><ul><li>Boolean(boolean value)：通过一个boolean值创建Boolean对象。</li><li>Boolean(String s)：通过字符串创建Boolean对象。s不能为null，s如果是忽略大小<br>写”true”则转换为true对象，其他字符串都转换为false对象。</li></ul></li><li><ol start="2"><li>compareTo()方法</li></ol><ul><li>Boolean类有int compareTo(Boolean包装类对象)方法，可以进行包装对象的比较。方法返回值是int，如果返回值是0，则相等；如果返回值小于0，则此对象小于参数对象；如果返回值大于0，则此对象大于参数对象。</li></ul></li><li><ol start="3"><li>字符串转换为boolean类型</li></ol><ul><li>Boolean包装类都提供静态parseBoolean()方法实现将字符串转换为对应的boolean类型，方法定义如下：</li><li>static boolean parseBoolean(String s)：将字符串转换为对应的boolean类。s不能为null，s如果是忽略大小写”true”则转换为true，其他字符串都转换为false。</li></ul></li></ul></li></ul></li><li><p>自动装箱/拆箱</p><ul><li>拆箱(unboxing )：拆箱能够将包装类对象自动转换为基本数据类型的数值，而不需要使用intValue()或doubleValue()等方法</li><li>自动装箱( autoboxing )：装箱能够自动地将基<br>本数据类型的数值自动转换为包装类对象，而不需要使用构造方法。</li><li>在自动装箱和拆箱时，要避免空对象，拆箱的过程本质上是调用intValue()方法实现的，试图访问空对象的方法和成员变量，就会抛出运行期NullPointerException异常。</li></ul></li></ul><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><ul><li><ol><li>舍入方法</li></ol><ul><li>static double ceil(double a)：返回大于或等于a最小整数。</li><li>static double floor(double a)：返回小于或等于a最大整数。</li><li>static int round(float a)：四舍五入方法。</li></ul></li><li><ol start="2"><li>最大值和最小值</li></ol><ul><li>static int min(int a, int b)：取两个int整数中较小的一个整数。</li><li>static int min(long a, long b)：取两个long整数中较小的一个整数。</li><li>static int min(float a, float b)：取两个float浮点数中较小的一个浮点数。</li><li>static int min(double a, double b)：取两个double浮点数中较小的一个浮点数。</li><li>max方法取两个数中较大的一个数，max方法与min方法参数类似也有4个版本</li></ul></li><li><ol start="3"><li>绝对值</li></ol><ul><li>static int abs(int a)：取int整数a的绝对值。</li><li>static long abs(long a)：取long整数a的绝对值。</li><li>static float abs(float a)：取float浮点数a的绝对值。</li><li>static double abs(double a)：取double浮点数a的绝对值。</li></ul></li><li><ol start="4"><li>三角函数</li></ol><ul><li>static double sin(double a)：返回角的三角正弦。</li><li>static double cos(double a)：返回角的三角余弦。</li><li>static double tan(double a)：返回角的三角正切。</li><li>static double asin(double a)：返回一个值的反正弦。</li><li>static double acos(double a)：返回一个值的反余弦。</li><li>static double atan(double a)：返回一个值的反正切。</li><li>static double toDegrees(double angrad)：将弧度转换为角度。</li><li>static double toRadians(double angdeg)：将角度转换为弧度。</li></ul></li><li><ol start="5"><li>对数运算</li></ol><ul><li>static double log(double a)，返回a的自然对数。</li></ul></li><li><ol start="6"><li>平方根</li></ol><ul><li>static double sqrt(double a)，返回a的正平方根。</li></ul></li><li><ol start="7"><li>幂运算</li></ol><ul><li>static double pow(double a, double b)，返回第一个参数的第二个参数次幂的值。</li></ul></li><li><ol start="8"><li>计算随机值</li></ol><ul><li>static double random()，返回大于等于 0.0 且小于 1.0随机数。</li></ul></li><li><ol start="9"><li>常量</li></ol><ul><li>圆周率PI</li><li>自然对数的底数E。</li></ul></li></ul><h3 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h3><ul><li><p>BigInteger</p><ul><li><p>java.math.BigInteger是不可变的任意精度的大整数。BigInteger构造方法有很多，其中字符串参数的构造方法有两个：</p><ul><li>BigInteger(String val)：将十进制字符串val转换为BigInteger对象。</li><li>BigInteger(String val, int radix)：按照指定基数radix将字符串val转换为BigInteger对象。</li></ul></li><li><p>BigInteger提供多种方法，常用方法如下：</p><ul><li>int compareTo(BigInteger val)：将当前对象与参数val进行比较，方法返回值是int，如果返回值是0，则相等；如果返回值小于0，则此对象小于参数对象；如果返回值大于0，则此对象大于参数对象。</li><li>BigInteger add(BigInteger val)：加运算，当前对象数值加参数val。</li><li>BigInteger subtract(BigInteger val)：减运算，当前对象数值减参数val。</li><li>BigInteger multiply(BigInteger val)：乘运算，当前对象数值乘参数val。</li><li>BigInteger divide(BigInteger val)：除运算，当前对象数值除以参数val。</li><li>BigInteger继承了抽象类Number，那么它还有实现抽象类Number的6个方法</li></ul></li></ul></li><li><p>BigDecimal</p><ul><li><p>java.math.BigDecimal是不可变的任意精度的有符号十进制数，BigDecimal构造方法有很多：</p><ul><li>BigDecimal(BigInteger val)：将BigInteger对象val转换为BigDecimal对象。</li><li>BigDecimal(double val)：将double转换为BigDecimal对象，参数val是double类型的二进制浮点值准确的十进制表示形式。</li><li>BigDecimal(int val)：将int转换为BigDecimal对象。</li><li>BigDecimal(long val)：将long转换为BigDecimal对象。</li><li>BigDecimal(String val)：将字符串表示数值形式转换为BigDecimal对象。</li></ul></li><li><p>BigDecimal提供多种方法，常用的方法如下：</p><ul><li>int compareTo(BigDecimal val)：将当前对象与参数val进行比较，方法返回值是int，如果返回值是0，则相等；如果返回值小于0，则此对象小于参数对象；如果返回值大于0，则此对象大于参数对象。</li><li>BigDecimal add(BigDecimal val)：加运算，当前对象数值加参数val。</li><li>BigDecimal subtract(BigDecimal val)：减运算，当前对象数值减参数val。</li><li>BigDecimal multiply(BigDecimal val)：乘运算，当前对象数值乘参数val。</li><li>BigDecimal divide(BigDecimal val)：除运算，当前对象数值除以参数val。</li><li>BigDecimal divide(BigDecimal val, int roundingMode)：除运算，当前对象数值除以参数val。roundingMode要应用的舍入模式。</li><li>BigDecimal继承了抽象类Number，那么它还实现抽象类Number的6个方法</li></ul></li></ul></li></ul><h3 id="日期时间相关类"><a href="#日期时间相关类" class="headerlink" title="日期时间相关类"></a>日期时间相关类</h3><ul><li><p>Java8之前日期相关类</p><ul><li><p>Date类</p><ul><li><p>在Java SE核心类中有两个Date，分别是java.util.Date和java.sql.Date。java.util.Date就是日期时间类，而java.sql.Date是JDBC中日期字段类型。</p></li><li><p>Java 8之前与日期时间相关类还有DateFormat、Calendar和TimeZone，DateFormat用于日期格式化，Calendar日历类，TimeZone是时区类。</p></li><li><p>构造方法</p><ul><li>Date()：用当前时间创建Date对象，精确到毫秒。</li><li>Date(long date)：指定标准基准时间以来的毫秒数创建Date对象。标准基准时间是格林威治时间<br>1970年1月1日00:00:00。</li></ul></li><li><p>普通方法</p><ul><li>boolean after(Date when)：测试此日期是否在when日期之后。</li><li>boolean before(Date when)：测试此日期是否在when日期之前。</li><li>int compareTo(Date anotherDate)：比较两个日期的顺序。如果参数日期等于此日期，则返回值0；如果此日期在参数日期之前，则返回小于0的值；如果此日期在参数日期之后，则返回大于0的值。</li><li>long getTime()：返回自1970年1月1日00:00:00以来此Date对象表示的毫秒数。</li><li>void setTime(long time)：用毫秒数time设置日期对象，time是自1970年1月1日00:00:00以来此Date对象表示的毫秒数。</li></ul></li><li><p>日期格式化和解析</p><ul><li><p>日期格式化类是java.text.DateFormat，DateFormat是抽象类，它的常用具体类<br>是java.text.SimpleDateFormat。</p></li><li><p>DateFormat中提供日期格式化和日期解析方法，具体方法说明如下：</p><ul><li>String format(Date date)：将一个Date格式化为日期/时间字符串。</li><li>Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期对象。如果解析失败则抛出ParseException。</li></ul></li><li><p>具体类是SimpleDateFormat构造方法如下：</p><ul><li>SimpleDateFormat()：用默认的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li><li>SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造<br>SimpleDateFormat。pattern参数是日期和时间格式模式</li></ul></li></ul></li></ul></li><li><p>Calendar类</p><ul><li><p>对日期时间进行操作，可以使用java.util.Calendar类，Calendar是一个抽象类，不能实例化，但是通过静态工厂方法getInstance()获得Calendar实例</p></li><li><p>主要方法</p><ul><li>static Calendar getInstance()：使用默认时区和语言环境获得一个日历。</li><li>void set(int field, int value)：将给定的日历字段设置为给定值。</li><li>void set(int year,int month,int date)：设置日历字段YEAR、MONTH和DAY_OF_MONTH的值</li><li>Date getTime()：返回一个表示此Calendar时间值（从1970年1月1日00:00:00至现在的毫秒数）的Date对象。</li><li>boolean after(Object when)：判断此Calendar表示的时间是否在指定时间之后，返回判断结果。</li><li>boolean before(Object when)：判断此Calendar表示的时间是否在指定时间之前，返回判断结果。</li><li>int compareTo(Calendar anotherCalendar)：比较两个Calendar对象表示的时间值。</li></ul></li></ul></li></ul></li><li><p>Java8新日期时间相关类</p><ul><li><p>时间和日期</p><ul><li><p>Java 8之后提供了新的日期时间类有三个：LocalDate、LocalTime和LocalDateTime，它们都位于java.time包中，LocalDate表示一个不可变的日期对象；LocalTime表示一个不可变的时间对象；LocalDateTime表示一个不可变的日期和时间。</p></li><li><p>这三个类有类似的方法，这三个类并没有提供公有的构造方法，创建它们对象可以使用静态工厂方法，主要有now()和of()方法。</p><ul><li><p>now()方法说明如下：</p><ul><li>static LocalDate now()：LocalDate静态工厂方法，该方法使用默认时区获得当前日期，返回<br>LocalDate对象。</li><li>static LocalTime now()：LocalTime静态工厂方法，该方法使用默认时区获得当前时间，返回<br>LocalTime对象。</li><li>static LocalDateTime now()：LocalDateTime静态工厂方法，该方法使用默认时区获得当前日期时间，返回LocalDateTime对象。</li></ul></li><li><p>of()方法有很多重载方法，说明如下：</p><ul><li>static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)：按照指定的年、月、日、小时、分钟和秒获得LocalDateTime实例，将纳秒设置为零。</li><li>static LocalTime of(int hour, int minute, int second)：按照指定的小时、分钟和秒获取一个<br>LocalTime实例。</li><li>static LocalDate of(int year, int month, int dayOfMonth)：按照指定的年、月和日获得一个<br>LocalDate实例，日期中年、月和日必须有效，否则将抛出异常。</li></ul></li></ul></li></ul></li><li><p>日期格式化和解析</p><ul><li><p>日期格式化</p><ul><li>日期格式化方法是format，这三个类每一个都有String format(DateTimeFormatter formatter)，参数formatter是DateTimeFormatter类型。</li></ul></li><li><p>日期解析</p><ul><li><p>日期解析方法是parse，这三个类每一个都有两个版本的parse方法</p><ul><li>static LocalDateTime parse(CharSequence text)：使用默认格式，从一个文本字符串获取一<br>个LocalDateTime实例，如2007-12-03T10:15:30。</li><li>static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter)：使用指定格式化，从文本字符串获取LocalDateTime实例。</li><li>static LocalDate parse(CharSequence text)：使用默认格式，从一个文本字符串获取一个<br>LocalDate实例，如2007-12-03。</li><li>static LocalDate parse(CharSequence text, DateTimeFormatter formatter)：使用指定格式化，从文本字符串获取LocalDate实例。</li><li>static LocalTime parse(CharSequence text)：使用默认格式，从一个文本字符串获取一个<br>LocalTime实例。</li><li>static LocalTime parse(CharSequence text, DateTimeFormatter formatter)：使用指定的格式化，从文本字符串获取LocalTime实例。</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul><li><p>内部类概述</p><ul><li>Java语言中允许在一个类（或方法、代码块）的内部定义另一个类，后者称为“内部类”（Inner<br>Classes），也称为“嵌套类”（Nested Classes），封装它的类称为“外部类”。内部类与外部类之间存在逻辑上的隶属关系，内部类一般只用在封装它的外部类或代码块中使用。</li></ul></li><li><p>内部类的作用</p><ul><li><ol><li>封装。将不想公开的实现细节封装到一个内部类中，内部类可以声明为私有的，只能在所在外部类中访问。</li></ol></li><li><ol start="2"><li>提供命名空间。静态内部类和外部类能够提供有别于包的命名空间。</li></ol></li><li><ol start="3"><li>便于访问外部类成员。内部类能够很方便访问所在外部类的成员，包括私有成员也能访问。</li></ol></li></ul></li><li><p>分类</p><ul><li><p>有名内部类</p><ul><li><p>局部内部类</p></li><li><p>成员内部类</p><ul><li>实例内部类</li><li>静态内部类</li></ul></li></ul></li><li><p>匿名内部类</p></li></ul></li><li><p>成员内部类</p><ul><li><p>成员内部类类似于外部类的成员变量，在外边类的内部，且方法体和代码块之外定义的内部类。</p></li><li><p>实例内部类</p><ul><li>实例内部类与实例变量类似，可以声明为公有级别、私有级别、默认级别或保护级别，即4种访问级别都可以，而外部类只能声明为公有或默认级别。</li><li>在内部类中this是引用当前内部类对象，而要引用外部类对象需要使用“外部类名.this”，如果内部类和外部类它们的成员命名没有冲突情况下，在引用外部类成员时可以不用加“外部类名.this”</li></ul></li><li><p>静态内部类</p><ul><li>静态内部类与静态变量类似，在声明的时候使用关键字static修饰，静态内部类只能访问外部类静态成员，所以静态内部类使用的场景不多。但可以提供有别于包的命名空间。</li><li>在声明静态内部时采用“内部类.静态内部类”形<br>式，实例化也是如此形式。</li></ul></li></ul></li><li><p>局部内部类</p><ul><li>局部内部类就是在方法体或代码块中定义的内部类，局部内部类的作用域仅限于方法体或代码块中。局部内部类访问级别只能是默认的，不能是公有的、私有的和保护的访问级别，即不能使用public、private和protected修饰。局部内部类也不能是静态，即不能使用static修饰。局部内部类可以访问外部类所有成员。</li><li>实例化内部类后马上调用它的方法，没有为内部类对象分配一个引用变量名，这种写法称为“匿名对象”。匿名对象适合只运行一次情况下。</li></ul></li><li><p>匿名内部类</p><ul><li>匿名内部类是没有名字的内部类，本质上是没有名的局部内部类，具有局部内部类所有特征。例如：可以访问外部类所有成员。如果匿名内部类在方法中定义，它所访问的参数需要声明为final的。</li><li>匿名内部类通常用来实现接口或抽象类的，很少覆盖具体类</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java面向对象&quot;&gt;&lt;a href=&quot;#Java面向对象&quot; class=&quot;headerlink&quot; title=&quot;Java面向对象&quot;&gt;&lt;/a&gt;Java面向对象&lt;/h1&gt;&lt;h2 id=&quot;面向对象基础&quot;&gt;&lt;a href=&quot;#面向对象基础&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Java" scheme="https://zql-gl.github.io/categories/Java/"/>
    
    
    <category term="知识文档" scheme="https://zql-gl.github.io/tags/%E7%9F%A5%E8%AF%86%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令</title>
    <link href="https://zql-gl.github.io/posts/4.html"/>
    <id>https://zql-gl.github.io/posts/4.html</id>
    <published>2022-10-22T05:30:00.000Z</published>
    <updated>2022-10-23T11:47:05.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h3 id="上下键"><a href="#上下键" class="headerlink" title="上下键"></a>上下键</h3><ul><li>选择之前执行过的历史命令，history指令可以查看历史指令列表</li></ul><h3 id="Tab键"><a href="#Tab键" class="headerlink" title="Tab键"></a>Tab键</h3><ul><li>自动补全准备输入的命令或文件名，如果按一下没有补全，就按两下，会列出所有可能的结果</li></ul><h3 id="CTRL-c"><a href="#CTRL-c" class="headerlink" title="CTRL+c"></a>CTRL+c</h3><ul><li>结束正在执行的命令。（如果还结束不了，关闭终端窗口）</li></ul><h3 id="clear或者CTRL-L"><a href="#clear或者CTRL-L" class="headerlink" title="clear或者CTRL+L"></a>clear或者CTRL+L</h3><ul><li>清除屏幕中的内容</li></ul><h2 id="终端命令"><a href="#终端命令" class="headerlink" title="终端命令"></a>终端命令</h2><h3 id="终端命令行与ls命令"><a href="#终端命令行与ls命令" class="headerlink" title="终端命令行与ls命令"></a>终端命令行与ls命令</h3><ul><li><p>ifconfig命令</p><ul><li>查看本机的IP地址</li></ul></li><li><p>[root@localhost ~]#</p><ul><li>root：当前登录的用户</li><li>@localhost:当前登录的系统名</li><li>~：当前所在目录 ~代表当前用户的主目录</li><li>#:代表管理员权限</li><li>$:代表普通用户权限</li></ul></li><li><p>ls命令:列出目录中的文件和文件夹</p><ul><li><p>ls -l 等价于 ll</p><ul><li>列出当前目录中的文件列表的详细信息（不显示隐藏文件）</li></ul></li><li><p>ls -a</p><ul><li>列出当前目录中的所有文件，包括隐藏文件(隐藏文件或文件夹名字以 . 开头)</li></ul></li><li><p>ls -A</p><ul><li>显示所有的文件和目录，包括隐藏文件和目录，但是不显示“.”和”..”目录</li></ul></li><li><p>ls -t</p><ul><li>根据时间排序</li></ul></li><li><p>ls /etc</p><ul><li>列出/etc目录下的文件信息</li></ul></li><li><p>ls -al 等价于 ls -a -l</p><ul><li>可以将单字母的选项一起写，两个功能都能实现</li></ul></li></ul></li></ul><h3 id="在线帮助命令"><a href="#在线帮助命令" class="headerlink" title="在线帮助命令"></a>在线帮助命令</h3><ul><li><p>man命令</p><ul><li>例如： man ls</li></ul></li><li><p>help命令</p><ul><li>查看外部命令的帮助文档，格式为“命令 –help”，如：passwd –help</li><li>查看内部命令的帮助文档，格式为“help 命令”，如：help ls</li></ul></li><li><p>type命令</p><ul><li>判断命令到底为内部命令还是外部命令</li><li>内部命令返回如： help is a shell builtin</li><li>外部命令返回如:  passwd is/usr/bin/passwd</li></ul></li><li><p>其他方式</p><ul><li>使用搜索引擎查找</li></ul></li><li><p>whereis命令</p><ul><li>用于查找与某一命令相关的文件的存放位置</li><li>whereis -b ：只查找二进制文件</li><li>whereis -m： 只查找手册页，说明文件</li><li>whereis -s：查找源程序文件</li></ul></li></ul><h3 id="文件和目录操作命令"><a href="#文件和目录操作命令" class="headerlink" title="文件和目录操作命令"></a>文件和目录操作命令</h3><ul><li><p>目录</p><ul><li>根目录：/</li><li>/etc:保存系统数据文件、启动文件和脚本等</li><li>/bin:存放普通用户常用的命令</li><li>/sbin:存放系统管理方面的常用命令</li><li>/boot:存放系统核心文件</li><li>/dev:存放与设备有关的文件</li><li>/lib:存放在编译某些程序时要用的函数库</li><li>/usr:存放用户安装的应用程序，类似于Windows系统中的program files目录</li><li>/var:存放系统数据文件</li><li>/root:系统管理员（root用户）的属主目录</li><li>/home:存放普通用户属主目录的目录</li><li>/media:在系统自动挂载存储设备时（如光驱、U盘）使用的目录</li><li>.  :表示当前目录</li><li>.. :表示当前目录的上一层目录</li><li>~ ：表示当前用户的属主目录</li></ul></li><li><p>vi编辑器</p><ul><li><p>一般模式</p><ul><li>数字0 ：光标移动到本行行首</li><li>$ :光标移动到本行行尾</li><li>G：光标移动到文本的最末行</li><li>gg：光标移动到该文本的首行</li><li>dd：删除光标所在的那一行</li><li>ndd(n为数字)：删除光标所在位置向下的n 行</li><li>x、X：x表示向后删除一个字符，X 表示向前删除一个字符</li></ul></li><li><p>编辑模式</p><ul><li>i:在当前字符前插入字符</li><li>a:在当前字符后插入字符</li><li>o:在当前行下插入新的一行</li><li>O：在当前行上插入新的一行</li><li>r:替换光标所在的字符，只替换一次</li></ul></li><li><p>命令行模式</p><ul><li>:w 将编辑过的文本保存</li><li>:q 退出vim</li><li>:wq 保存文本 ，并退出</li><li>:q!  不管编辑或不编辑文本都不保存并退出</li></ul></li></ul></li><li><p>文件与目录操作命令</p><ul><li><p>cd命令</p><ul><li>cd  相对路径或绝对路径</li><li>cd .. 返回上一级目录</li><li>cd ~ 回到自己的属主目录</li></ul></li><li><p>pwd命令</p><ul><li>用于显示当前所在的目录</li></ul></li><li><p>mkdir命令</p><ul><li>mkdir 目录名称   用于创建目录</li><li>mkdir 目录名称 目录名称 用于创建多个目录</li></ul></li><li><p>rmdir命令</p><ul><li>rmdir 目录名称  用于删除目录，删除文件夹时，文件夹必须是空的</li></ul></li><li><p>cp命令</p><ul><li>用于复制文件，对文件的重命名</li></ul></li><li><p>rm命令</p><ul><li><p>用于删除文件</p><ul><li>rm -f 强制删除，不提示用户是否需要删除的信息</li><li>rm -r 循环删除，常用于删除目录</li></ul></li></ul></li><li><p>mv命令</p><ul><li>用于移动文件或目录，对文件或目录的重命名操作</li></ul></li><li><p>管道命令 （|）将|左边命令的输出结果作为|右边命令的输入数据</p></li></ul></li><li><p>创建目录或文件</p><ul><li><p>mkdir命令</p><ul><li>mkdir 目录名称   用于创建目录</li><li>mkdir 目录名称 目录名称 用于创建多个目录</li></ul></li><li><p>touch命令</p><ul><li>创建一个或多个空文件</li><li>touch  文件路径文件名</li></ul></li><li><p>cat &gt;</p><ul><li>如果原来有内容就覆盖原内容</li></ul></li><li><p>cat &gt;&gt;</p><ul><li>追加内容</li></ul></li><li><p>vi编辑器</p><ul><li>vi  文件名称</li></ul></li></ul></li><li><p>查看文件内容命令</p><ul><li><p>cat命令</p><ul><li>cat -n ：连行号一起显示在屏幕上</li><li>cat -b：连行号一起显示在屏幕上，但空行不算</li><li>cat -v：显示控制符号</li></ul></li><li><p>more命令</p><ul><li>用于在屏幕上显示文件内容</li><li>用于分页显示文件列表</li><li>more +n:从第n行开始显示</li><li>more -n:定义屏幕大小为n行，就是每页显示n行</li><li>退出按Q键</li></ul></li><li><p>less命令</p><ul><li>查看文件内容</li><li>less -N：显示每行行号</li><li>退出按Q键</li></ul></li><li><p>head命令</p><ul><li>查看文件的前几行，默认显示10行   </li><li>head -n :表示指定显示多少行</li></ul></li><li><p>tail命令</p><ul><li>显示文件的后几行，默认显示10行  </li><li>tail -n :表示指定显示多少行</li></ul></li></ul></li><li><p>文件与目录权限</p><ul><li><p>chown命令</p><ul><li>用于变更文件及目录的所有者和所属组</li><li>chown -R :表示连同目录下所有文件及子目录都进行变更</li></ul></li><li><p>chmod命令</p><ul><li>修改文件或目录的读写执行权限</li><li>chmod -R :表示连同目录下所有文件及子目录都进行变更</li></ul></li></ul></li><li><p>搜索文件或目录</p><ul><li><p>grep命令</p><ul><li>只显示文件中符合指定条件的行</li><li>grep  需要查找的内容 查找的文件名</li><li>grep -i 需要查找的内容 查找的文件名  查找内容的行，忽略大小写 </li><li>grep -n 需要查找的内容 查找的文件名  查找并显示行号</li></ul></li><li><p>which命令</p><ul><li>用于查找可执行文件的位置</li><li>在当前用户的环境变量PATH路径中寻找指令文件</li></ul></li><li><p>whereis命令</p><ul><li>用于根据设定好的目录查找文件</li><li>查找指令文件，帮助文档及源代码等内容</li></ul></li><li><p>find命令</p><ul><li>用于对指定目录及其所有子目录进行文件搜索</li><li>用find命令查找数据比较消耗硬盘空间（find命令直接查找硬盘数据）</li></ul></li><li><p>locate命令</p><ul><li>查找文件，根据文件列表的数据库查找，速度快，但更新不及时，  updatedb 更新文件列表数据库</li></ul></li></ul></li><li><p>文件打包与压缩</p><ul><li><p>gzip命令</p><ul><li>gzip 文件名   压缩文件为  文件名.gz</li><li>gzip -d  文件名.gz  解压文件</li></ul></li><li><p>zip命令</p><ul><li>zip 文件名.zip  文件名 文件名 可以压缩一个或多个文件</li><li>unzip 文件名.zip 解压缩</li><li>unzip 文件名.zip -d 目录路径   解压到指定目录</li></ul></li><li><p>tar命令</p><ul><li>文件打包与解包</li><li>tar -cvf 文件名.tar  文件名   打包不压缩</li><li>tar -zcvf 文件名.tar.gz  文件名  打包压缩</li><li>tar -xvf 文件名.tar  解包到当前文件夹</li><li>tar -zxvf 文件名.tar.gz  解压到当前文件夹</li><li>tar -zxvf 文件名.tar.gz -C  目录路径  解压到指定目录</li></ul></li></ul></li></ul><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ul><li><p>链接文件  </p><ul><li>ln -选项 源文件 链接文件</li><li>ln命令：新建链接文件</li><li>ln -d  创建硬链接，默认为该参数</li><li>ln -s  创建符号链接</li><li>ln -f 在创建链接时，如果目标文件已经存在，则对其进行替换</li><li>ls -il:查看索引节点号</li></ul></li><li><p>硬盘光盘</p><ul><li><p>df命令</p><ul><li>df -hT 查看硬盘使用情况</li></ul></li><li><p>du命令</p><ul><li>du -sh /home  只查看home目录容量使用情况</li></ul></li><li><p>mount命令</p><ul><li>mount /dev/sr0 /media  将光盘挂载到 /media 文件夹</li><li>umount /dev/sr0  取消挂载</li></ul></li></ul></li></ul><h2 id="Linux系统的管理"><a href="#Linux系统的管理" class="headerlink" title="Linux系统的管理"></a>Linux系统的管理</h2><h3 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h3><ul><li>shutdown -t  数字  指定多少秒后关机</li><li>shutdown -r  时间  指定时间关机后立即重新开机</li><li>shutdown -r now  现在就重启计算机</li><li>shutdown -h  时间   指定时间关机</li><li>shutdown -h now 立即关机</li><li>poweroff 也是立即关机（不能设置关机时间）</li><li>halt  -p  表示挂起系统后关闭系统，相当于 shutdown -h  是最简单的关机命令</li><li>shutdown -c  取消关机进程</li><li>reboot   用于重启计算机 相当于 shutdown -r now</li></ul><h3 id="用户和组管理"><a href="#用户和组管理" class="headerlink" title="用户和组管理"></a>用户和组管理</h3><ul><li><p>groupadd命令</p><ul><li>新建群组</li></ul></li><li><p>groupdel命令</p><ul><li>删除已存在的群组</li></ul></li><li><p>useradd命令</p><ul><li>新建用户  useradd  用户名</li></ul></li><li><p>userdel命令</p><ul><li>删除用户   userdel -r 用户名  删除用户及其主目录中的所有文件</li></ul></li><li><p>usermod命令</p><ul><li>修改用户信息</li></ul></li><li><p>passwd命令</p><ul><li>为用户设定密码</li></ul></li><li><p>su命令</p><ul><li>切换用户   su - 用户名  切换为什么用户</li></ul></li><li><p>sudo命令</p><ul><li>以管理员权限执行指令</li></ul></li><li><p>id命令</p><ul><li>用于显示用户的UID、GID及所拥有的群组</li></ul></li><li><p>groups命令</p><ul><li>用于显示用户所属的群组信息</li></ul></li></ul><h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><ul><li><p>查看磁盘空间</p><ul><li><p>df命令</p><ul><li>用于显示磁盘空间的使用情况</li></ul></li><li><p>du命令</p><ul><li>用于显示指定目录下所有文件及子目录所占用的磁盘空间大小</li></ul></li></ul></li><li><p>磁盘分割</p><ul><li><p>fdisk命令</p><ul><li>用于显示或进行分区</li></ul></li></ul></li><li><p>设备挂载</p><ul><li><p>mount命令</p><ul><li>用于挂载存储设备</li></ul></li><li><p>umount命令</p><ul><li>用于卸载已经挂载的设备</li></ul></li></ul></li></ul><h3 id="安装包管理"><a href="#安装包管理" class="headerlink" title="安装包管理"></a>安装包管理</h3><ul><li><p>rpm命令</p><ul><li>rpm -ivh rpm包名：用于Linux系统下的软件套件安装</li><li>rpm -e 套件名：卸载指定套件</li><li>rpm -e –nodeps 套件名：强制卸载，不考虑套件之间的依赖性</li></ul></li><li><p>yum命令</p><ul><li>yum install 包名：安装指定的包</li><li>yum erase 包名：卸载指定的包</li><li>yum remove 包名：删除已安装的包</li></ul></li><li><p>源码包</p><ul><li>使用源码安装</li></ul></li></ul><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ul><li><p>后台工作管理</p><ul><li><p>&amp;命令</p><ul><li>将当前工作放到后台运行</li></ul></li><li><p>Ctrl+Z组合键</p><ul><li>暂停某工作</li></ul></li><li><p>fg命令</p><ul><li>将后台的工作放到前台来执行</li></ul></li><li><p>jobs命令</p><ul><li>用于查询所有后台的任务</li></ul></li></ul></li><li><p>系统状态监控</p><ul><li><p>ps命令</p><ul><li>用于显示当前系统中运行的进程</li><li>ps aux :列出目前所有内存当中的程序</li><li>ps -ef：列出系统中的所有进程</li></ul></li><li><p>w命令</p><ul><li>用于 查看当前系统负载</li></ul></li><li><p>vmstat命令</p><ul><li>用于监控当前系统状态</li></ul></li><li><p>top命令</p><ul><li>用于动态监控进程所占系统资源，每隔3秒更新一次</li></ul></li><li><p>free命令</p><ul><li>用于查看内存使用情况</li></ul></li><li><p>kill命令</p><ul><li>用于停止进程</li></ul></li></ul></li></ul><h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><ul><li><p>ifconfig命令</p><ul><li>用于显示或设置网卡</li></ul></li><li><p>netstat命令</p><ul><li>用于显示网络连接情况</li><li>netstat -Inp:用于显示当前系统启用哪些端口</li><li>netstat -an：用于显示网络连接情况</li></ul></li><li><p>ping命令</p><ul><li>用于测试目标与本机的连接情况</li></ul></li></ul><h3 id="服务脚本和安全设置"><a href="#服务脚本和安全设置" class="headerlink" title="服务脚本和安全设置"></a>服务脚本和安全设置</h3><ul><li><p>service命令</p><ul><li>用于执行/etc/init.d目录下的服务脚本</li><li>service network restart：重启网络服务</li><li>start ：启动服务</li><li>stop：结束服务</li><li>restart ：重启服务</li><li>status ：显示服务状态</li></ul></li><li><p>setenforce命令</p><ul><li>用于设置SELinux的状态</li><li>setenforce 0：用来关闭SELinux</li><li>setenforce 1：用来开启SELinux</li></ul></li><li><p>getenforce命令</p><ul><li>用于显示当前SELinux的状态</li></ul></li><li><p>防火墙iptables</p><ul><li>service iptables start：开启防火墙</li><li>service iptables stop：关闭防火墙</li></ul></li></ul><h2 id="Web服务器环境的搭建"><a href="#Web服务器环境的搭建" class="headerlink" title="Web服务器环境的搭建"></a>Web服务器环境的搭建</h2><h3 id="安装LAMP"><a href="#安装LAMP" class="headerlink" title="安装LAMP"></a>安装LAMP</h3><ul><li><p>登陆Linux系统</p><ul><li>使用root用户登陆</li></ul></li><li><p>关闭防火墙</p><ul><li>setenforce 0</li></ul></li><li><p>安装Apache</p><ul><li>yum install httpd：安装httpd</li><li>systemctl start httpd.service：启动Apache服务</li></ul></li><li><p>安装MySQL</p></li><li><p>安装PHP</p></li><li><p>重启服务</p></li></ul><h3 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h3><ul><li><p>查看CentOS 是否自带了JDK，如果没有需要先安装JDK</p></li><li><p>复制Tomcat安装包到root用户的属主目录下</p></li><li><p>解压安装包</p></li><li><p>查看Tomcat的默认端口</p><ul><li>8080</li></ul></li><li><p>启动Tomcat</p></li><li><p>获取Linux系统的IP地址，在物理机浏览器中输入“<a href="http://Linux系统的IP地址:8080”来打开">http://Linux系统的IP地址:8080”来打开</a></p></li></ul><h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><h3 id="BASH是centos默认使用的shell"><a href="#BASH是centos默认使用的shell" class="headerlink" title="BASH是centos默认使用的shell"></a>BASH是centos默认使用的shell</h3><ul><li><p>记录历史命令！</p><ul><li>！！：表示执行上一条指令</li><li>！n(n是数字)：表示执行历史命令中第n条指令</li><li>! 字符串：表示执行历史命令中最近一次以“字符串”为开头的指令</li></ul></li><li><p>指令和文件名补全</p><ul><li>tab键</li></ul></li><li><p>别名alias</p></li><li><p>通配符</p><ul><li><ul><li>：匹配零个或多个字符</li></ul></li><li>？:匹配一个字符</li></ul></li><li><p>输入/输出重定向</p><ul><li>&lt;：输入重定向</li><li><blockquote><p>：输出重定向</p></blockquote></li><li><blockquote><blockquote><p>：追加重定向</p></blockquote></blockquote></li></ul></li><li><p>管道符</p><ul><li>|:将前面命令的运行结果作为后面命令的输入条件</li></ul></li><li><p>作业控制</p><ul><li>Ctrl+Z：暂停进程</li><li>fg：恢复进程</li><li>bg：使进程在后台运行</li><li>Ctrl+C：终止进程</li></ul></li></ul><h3 id="shell中的编码规范"><a href="#shell中的编码规范" class="headerlink" title="shell中的编码规范"></a>shell中的编码规范</h3><ul><li><p>echo命令</p><ul><li>用于向窗口输出文本、字符串</li></ul></li><li><p>shell注释</p><ul><li>以#开头的行，只有单行注释</li></ul></li><li><p>变量</p><ul><li>局部变量</li><li>环境变量</li><li>shell变量</li></ul></li><li><p>数据类型</p><ul><li>字符创</li><li>shell数组</li></ul></li><li><p>shell基本运算符</p><ul><li>算术运算符</li><li>关系运算符</li><li>布尔运算符</li><li>字符串运算符</li></ul></li><li><p>shell流程控制</p><ul><li>if条件控制</li><li>for循环控制</li><li>while循环控制</li><li>until循环</li><li>case语句</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux常用命令&quot;&gt;&lt;a href=&quot;#Linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令&quot;&gt;&lt;/a&gt;Linux常用命令&lt;/h1&gt;&lt;h2 id=&quot;常用快捷键&quot;&gt;&lt;a href=&quot;#常用快捷键&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Linux" scheme="https://zql-gl.github.io/categories/Linux/"/>
    
    
    <category term="知识文档" scheme="https://zql-gl.github.io/tags/%E7%9F%A5%E8%AF%86%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识</title>
    <link href="https://zql-gl.github.io/posts/2.html"/>
    <id>https://zql-gl.github.io/posts/2.html</id>
    <published>2022-10-20T15:00:00.000Z</published>
    <updated>2022-10-22T06:35:39.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h1><h2 id="Java语法基础"><a href="#Java语法基础" class="headerlink" title="Java语法基础"></a>Java语法基础</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>标识符就是变量、常量、方法、枚举、类、接口等由程序员指定的名字。构成标识符的字母均有一定的规范，Java语言中标识符的命名规则如下</li><li>01.区分大小写：Myname与myname是两个不同的标识符。</li><li><ol start="2"><li>首字符，可以是下划线（_）或美元符或字母，但不能是数字。</li></ol></li><li><ol start="3"><li>除首字符外其他字符，可以是下划线（_）、美元符、字母和数字。</li></ol></li><li><ol start="4"><li>关键字不能作为标识符。</li></ol></li></ul><h3 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h3><ul><li><p>访问控制</p><ul><li>private    私有的</li><li>public    公共的</li><li>default    默认</li><li>protected    受保护的</li></ul></li><li><p>类、方法和变量修饰符</p><ul><li>abstract    声明抽象</li><li>class    类</li><li>extends    扩充,继承</li><li>final    最终值,不可改变的</li><li>implements    实现（接口）</li><li>interface    接口</li><li>native    本地，原生方法（非 Java 实现）</li><li>new    新,创建</li><li>static    静态</li><li>strictfp    严格,精准</li><li>synchronized    线程,同步</li><li>transient    短暂</li><li>volatile    易失</li></ul></li><li><p>程序控制语句</p><ul><li>break    跳出循环</li><li>case    定义一个值以供 switch 选择</li><li>continue    继续</li><li>do    运行</li><li>else    否则</li><li>for    循环</li><li>if    如果</li><li>instanceof    实例</li><li>return    返回</li><li>switch    根据值选择执行</li><li>while    循环</li></ul></li><li><p>错误处理</p><ul><li>assert    断言表达式是否为真</li><li>catch    捕捉异常</li><li>finally    有没有异常都执行</li><li>throw    抛出一个异常对象</li><li>throws    声明一个异常可能被抛出</li><li>try    捕获异常</li></ul></li><li><p>包相关</p><ul><li>import     引入</li><li>package    包</li></ul></li><li><p>基本类型</p><ul><li>boolean    布尔型</li><li>char    字符型</li><li>double    双精度浮点</li><li>byte    字节型</li><li>float    单精度浮点</li><li>int    整型</li><li>short    短整型</li><li>long    长整型</li></ul></li><li><p>变量引用</p><ul><li>super  父类，超类</li><li>void    无返回值</li><li>this    本类</li></ul></li></ul><h3 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h3><ul><li>goto    是关键字，但不能使用</li><li>const    是关键字，但不能使用</li></ul><h3 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h3><ul><li>在Java源代码中，有一些字符被用作分隔，称为分隔符。分隔符主要有：分号（;）、左右大括号<br>（{}）和空白。</li></ul><h3 id="Java的常量与变量"><a href="#Java的常量与变量" class="headerlink" title="Java的常量与变量"></a>Java的常量与变量</h3><ul><li><p>Java常量</p><ul><li><p>常量在声明的同时需要赋予一个初始值，声明格式：final 数据类型 变量名 = 初始值;</p></li><li><p>使用final关键字来修饰常量，声明方式和变量类似，通常用大写字母表示常量</p></li><li><p>字符串常量包含在两个引号之间的字符序列，和字符变量都可以包含任何Unicode字符</p></li><li><p>定义变量的时候，如果加上final修饰符，这个变量就变成了常量</p></li><li><p>Java 的 null 不是关键字，类似于 true 和 false，它是一个字面常量，不允许作为标识符使用</p></li><li><p>分类</p><ul><li><p>静态常量</p><ul><li>在final 之前使用public static修饰，用来替代保留字const。</li><li>public static修饰的常量作用域是全局的，不需<br>要创建对象就可以访问它，在类外部访问形式：HelloWorld. PI   （类名.常量名）</li></ul></li><li><p>成员常量</p></li><li><p>局部常量</p></li></ul></li></ul></li><li><p>Java变量</p><ul><li><p>类变量（静态变量）：独立于方法之外的变量，用 static 修饰。</p><ul><li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li><li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li><li>静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。</li><li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li><li>静态变量在第一次被访问时创建，在程序结束时销毁。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li><li>默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：ClassName.VariableName的方式访问。</li><li>类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul></li><li><p>实例（成员）变量：独立于方法之外的变量，不过没有 static 修饰。成员变量是在类体中，而在方法之外，作用域是整个类，如果没有赋初始值，系统使用默认值</p><ul><li>成员变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>成员变量在对象创建的时候创建，在对象被销毁的时候销毁；</li><li>成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li>访问修饰符可以修饰实例变量；</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li><li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObjectReference.VariableName。</li></ul></li><li><p>局部变量：是在方法或if、for和while等代码块中声明的变量。</p><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li>访问修饰符不能用于局部变量；</li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在栈上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul></li></ul></li></ul><h2 id="Java编码规范"><a href="#Java编码规范" class="headerlink" title="Java编码规范"></a>Java编码规范</h2><h3 id="命名规范（驼峰命名）"><a href="#命名规范（驼峰命名）" class="headerlink" title="命名规范（驼峰命名）"></a>命名规范（驼峰命名）</h3><ul><li><p>小驼峰命名</p><ul><li>小驼峰法就是第一个单词是全部小写，后面的单词首字母大写</li></ul></li><li><p>大驼峰命名</p><ul><li>大驼峰法是第一个单词的首字母也大写</li></ul></li><li><p>除了包和常量外，Java编码规范命名方法采用驼峰法</p><ul><li>包名：包名是全小写字母，中间可以由点分隔开。作为命名空间，包名应该具有唯一性</li><li>常量名：全大写，如果是由多个单词构成，可以用下划线隔开如YEAR和WEEK_OF_MONTH。</li><li>类和接口名：采用大驼峰法</li><li>文件名：采用大驼峰法</li><li>变量：采用小驼峰法</li><li>方法名：采用小驼峰法</li></ul></li></ul><h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><ul><li><p>文档注释：/**    */</p><ul><li>文档注释就是指这种注释内容能够生成API帮助文档，JDK中javadoc命令能够提取这些注释信息并生成HTML文件。文档注释主要对类（或接口）、实例变量、静态变量、实例方法和静态方法等进行注释。</li><li>生成文档后，会生成很多HTML文件，其中的index.html文件是文档的入口</li></ul></li><li><p>多行注释</p><ul><li>/*   */</li></ul></li><li><p>单行注释</p><ul><li>//</li></ul></li></ul><h3 id="代码排版"><a href="#代码排版" class="headerlink" title="代码排版"></a>代码排版</h3><ul><li><p>空行用以将逻辑相关的代码段分隔开，以提高可读性，空行使用规范：</p><ul><li><ol><li>类声明和接口声明之间保留两个空行</li></ol></li><li><ol start="2"><li>两个方法之间保留一个空行</li></ol></li><li><ol start="3"><li>方法的第一条语句之前保留一个空行</li></ol></li><li><ol start="4"><li>代码注释（尾端注释外）之前保留一个空行</li></ol></li><li><ol start="5"><li>一个方法内的两个逻辑段之间</li></ol></li></ul></li><li><p>代码中的有些位置是需要有空格的，空格的规范：</p><ul><li><ol><li>赋值符号“=”前后各有一个空格</li></ol></li><li><ol start="2"><li>所有的二元运算符都应该使用空格与操作数分开</li></ol></li><li><ol start="3"><li>一元操作符：负号“-”、自增“++”和自减“–”等，它们与操作数之间没有空格</li></ol></li><li><ol start="4"><li>小左括号“(”之后，小右括号“)”之前不应有空格</li></ol></li><li><ol start="5"><li>大左括号“{”之前有一个空格</li></ol></li><li><ol start="6"><li>方法参数列表小左括号“(”之前没有空格，小右括号“)”之后有一个空格，参数列表中参数逗号“,”之后也有一个空格。</li></ol></li><li><ol start="7"><li>关键字之后紧跟着小左括号“(”，关键字之后应该有一个空格</li></ol></li></ul></li><li><p>缩进的规范</p><ul><li><ol><li>在方法、Lambda、控制语句等包含大括号“{}”的代码块中，代码块的内容相对于首行缩进一个级别（4个空格）</li></ol></li><li><ol start="2"><li>如果是if语句中条件表达式的断行，那么新的一行应该相对于上一行缩进两个级别（8个空<br>格），再往后的断行要与第一次的断行对齐</li></ol></li></ul></li><li><p>一行代码的长度应尽量不要超过80个字符，如果超过则需断行，断行的规范</p><ul><li><ol><li>在一个逗号后面断开。</li></ol></li><li><ol start="2"><li>在一个操作符前面断开，要选择较高级别的运算符（而非较低级别的运算符）断开。</li></ol></li><li><ol start="3"><li>新的一行应该相对于上一行缩进两个级别（8个空格）。</li></ol></li></ul></li><li><p>其他规范</p><ul><li><ol><li>在声明变量或常量时推荐一行一个声明</li></ol></li><li><ol start="2"><li>左大括号“{”位于声明语句同行的末尾。右大括号“}”另起一行，与相应的声明语句对齐，除非<br>是一个空语句，右大括号“}”应紧跟在左大括号“{”之后</li></ol></li><li><ol start="3"><li>每行至多包含一条语句</li></ol></li><li><ol start="4"><li>虽然Java语言允许if、for等控制语句只有一行代码情况下，省略左右两个大括号，但是编码规范并不推荐这样使用</li></ol></li></ul></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li><p>数值类型</p><ul><li><p>整数类型（默认int）</p><ul><li>byte：8位，默认是0</li><li>short：2个字节，默认是0</li><li>int：4个字节，默认是0</li><li>long：8个字节，默认是0L</li></ul></li><li><p>浮点数类型（默认double）</p><ul><li>float：4个字节，默认是0.0f</li><li>double：8个字节,默认是0.0d</li></ul></li><li><p>字符类型</p><ul><li>char:2个字节，范围\u0000(0)~\uffff(65535),默认值是’u0000’</li><li>字符常量必须用单引号括起来的单个字<br>符</li></ul></li></ul></li><li><p>布尔类型</p><ul><li>boolean：true or  false,默认是false</li></ul></li><li><p>转义字符</p><ul><li>\n:换行（0x0a）</li><li>\r：回车（0x0d）</li><li>\t    制表符</li><li>\f：换页符（0x0c）</li><li>\b    退格 (0x08)</li><li>\0    空字符 (0x0)</li><li>\s    空格 (0x20)</li><li>"    双引号</li><li>'    单引号</li><li>\    反斜杠</li><li>\ddd    八进制字符 (ddd)</li><li>\uxxxx    16进制Unicode字符 (xxxx)</li></ul></li><li><p>数据类型转换</p><ul><li><p>自动类型转换</p><ul><li>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。<br>转换从低级到高级：byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double </li><li>规则：1. 不能对boolean类型进行类型转换。</li></ul></li></ul></li></ul><ol start="2"><li><p>不能把对象类型转换成不相关类的对象。</p></li><li><p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p></li><li><p>转换过程中可能导致溢出或损失精度</p></li><li><p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入</p><ul><li><p>强制类型转换</p><ul><li><ol><li>条件是转换的数据类型必须是兼容的。</li></ol></li><li><ol start="2"><li>格式：(type)value type是要强制类型转换后的数据类型 </li></ol></li></ul></li><li><p>隐含强制类型转换</p><ul><li>1、 整数的默认类型是 int。</li><li><ol start="2"><li>小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。</li></ol></li></ul></li></ul></li></ol><ul><li><p>数字表示方式</p><ul><li><p>进制数字表示方式</p><ul><li>二进制数：以 0b 或0B为前缀，注意0是阿拉伯数字，不要误认为是英文字母o。</li><li>八进制数：以0为前缀，注意0是阿拉伯数字。</li><li>十六进制数：以 0x 或0X为前缀，注意0是阿拉伯数字</li></ul></li><li><p>指数表示</p><ul><li>如果采用十进制表示指数，需要使用大写或小写的e表示幂，e2表示10的2次方。</li></ul></li></ul></li></ul><h3 id="引用数据类型（String）"><a href="#引用数据类型（String）" class="headerlink" title="引用数据类型（String）"></a>引用数据类型（String）</h3><ul><li><p>引用数据类型变量中保持的是指向对象的内存地址（引用数据类型在使用之前一定要：声明和初始化）默认值是null</p></li><li><p>类</p></li><li><p>接口</p></li><li><p>数组</p><ul><li>元素数据类型[] 数组变量名;   推荐使用这种声明方式</li></ul></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ul><li><p>一元运算</p><ul><li>-（取反）、++（自增）、–（自减）</li><li>前缀自增自减法(++a,–a): 先进行自增或者自减运算，再进行表达式运算。</li><li>后缀自增自减法(a++,a–): 先进行表达式运算，再进行自增或者自减运算 </li></ul></li><li><p>二元运算</p><ul><li>+、-、*、/、%</li></ul></li></ul><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul><li>&amp;（位与）、|（位或）、~（位反）、^(位异或)、&lt;&lt;（左移）、&gt;&gt;（有符号右移）、&gt;&gt;&gt;（无符号右移）、&amp;=（位与等于）、|=（位或等于）、^=（位异或等于）、&lt;&lt;=（左移等于）、&gt;&gt;=（右移等于）、&gt;&gt;&gt;=（右移等于）</li></ul><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul><li>==、!=、&gt;、&lt;、&gt;=、&lt;=</li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li>!（逻辑非）、&amp;（逻辑与）、|（逻辑或）、&amp;&amp;（短路与）、||（短路或）</li></ul><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul><li><p>算术赋值运算符</p><ul><li>+=、-=、*=、/=、%=</li></ul></li></ul><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><ul><li><p>三元运算符 (?:)</p><ul><li>variable x = (expression) ? value if true : value if false</li><li>三元运算符（? :）。例如x?y:z;，其中x、y和z都为表达式。</li></ul></li><li><p>instanceof 运算符</p><ul><li>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）</li><li>instanceof运算符使用格式:( Object reference variable ) instanceof  (class/interface type)</li></ul></li><li><p>小括号。起到改变表达式运算顺序的作用，它的优先级最高。</p></li><li><p>中括号。数组下标。</p></li><li><p>引用号（.）。对象调用实例变量或实例方法的操作符，也是类调用静态变量或静态方法的操作符。</p></li><li><p>赋值号（=）。赋值是用等号运算符（=）进行的。</p></li><li><p>new。对象内存分配运算符。</p></li><li><p>箭头（-&gt;）。Java 8新增加的，用来声明Lambda表达式。</p></li><li><p>双冒号（::）。Java 8新增加的，用于Lambda表达式中方法的引用。</p></li></ul><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="分支（条件）语句"><a href="#分支（条件）语句" class="headerlink" title="分支（条件）语句"></a>分支（条件）语句</h3><ul><li><p>if语句</p><ul><li><p>if语句</p><ul><li>if(布尔表达式)<br>{<br>//如果布尔表达式为true将执行的语句<br>}</li><li>如果布尔表达式的值为 true，则执行 if 语句中的代码块，否则执行 if 语句块后面的代码。</li></ul></li><li><p>if…else语句</p><ul><li>if(布尔表达式){<br>//如果布尔表达式的值为true<br>}else{<br>//如果布尔表达式的值为false<br>}</li><li>if 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。</li></ul></li><li><p>if…else if…else 语句</p><ul><li>if(布尔表达式 1){<br>//如果布尔表达式 1的值为true执行代码<br>}else if(布尔表达式 2){<br>//如果布尔表达式 2的值为true执行代码<br>}else if(布尔表达式 3){<br>//如果布尔表达式 3的值为true执行代码<br>}else {<br>//如果以上布尔表达式都不为true执行代码<br>}</li><li>if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。</li><li>if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。</li><li>一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。</li></ul></li></ul></li><li><p>switch case 语句</p><ul><li><p>switch(expression){<br>case value1:<br> //语句<br> break; //可选<br>case value2:<br> //语句<br> break; //可选<br>//你可以有任意数量的case语句<br>default : //可选<br> //语句<br>}</p></li><li><p>规则</p><ul><li>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</li><li>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</li><li>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li><li>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</li><li>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</li><li>switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</li></ul></li><li><p>switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。</p></li></ul></li></ul><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><ul><li><p>while 循环</p><ul><li>while( 布尔表达式 ) {<br> //循环内容<br>}</li><li>只要布尔表达式为 true，循环就会一直执行下去</li><li>如果循环体中需要循环变量，就必须在while语句之前对循环变量进行初始化</li></ul></li><li><p>do…while 循环</p><ul><li>do {<br> //代码语句<br>}while(布尔表达式);</li><li>对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。</li><li>布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。</li></ul></li><li><p>for 循环</p><ul><li>for(初始化; 布尔表达式; 更新) {<br>//代码语句<br>}</li><li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</li><li>然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</li><li>执行一次循环后，更新循环控制变量。</li><li>再次检测布尔表达式。循环执行上面的过程。</li></ul></li><li><p>Java 增强 for 循环–for-each语句</p><ul><li>Java5 引入了一种主要用于数组的增强型 for 循环。遍历集合使用for-each比较方便</li><li>for(声明语句 : 表达式)<br>{<br>//代码句子<br>}</li><li>声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</li><li>表达式：表达式是要访问的数组名，或者是返回值为数组的方法。</li></ul></li></ul><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><ul><li><p>break语句</p><ul><li>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</li><li>break 跳出最里层的循环，并且继续执行该循环下面的语句。</li><li>break还可以配合标签使用，多层循环的时候想要跳出外循环，可以为外循环添加一个标签，注意在定义标签的时候后面跟一个冒号，程序会跳转出标签所指定的循环</li></ul></li><li><p>continue语句</p><ul><li>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</li><li>在 for 循环中，continue 语句使程序立即跳转到更新语句。</li><li>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。</li><li>默认情况下，continue只会跳出最近的内循环，可以为外循环添加一个标签，continue语句后面指定这个标签，这样当条件满足执行continue语句时，程序就会跳转出外循环。</li></ul></li><li><p>return语句</p></li><li><p>throw语句</p></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><ul><li><p>声明语法：元素数据类型[] 数组变量名;</p></li><li><p>数组初始化</p><ul><li><p>静态初始化</p><ul><li>将数组的元素放到大括号中，元素之间用逗号（,）分隔</li></ul></li><li><p>动态初始化</p><ul><li>动态初始化使用new运算符分配指定长度的内存空间，</li><li>语法： new 元素数据类型[数组长度] ;</li></ul></li></ul></li></ul><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ul><li><p>声明语法：元素数据类型[][] 数组变量名;</p></li><li><p>二维数组初始化</p><ul><li><p>静态初始化</p><ul><li>int intArray[][] = { { 1, 2, 3 }, { 11, 12, 13 }, { 21, 22, 23 }, { 31, 32, 33 } };</li></ul></li><li><p>动态初始化</p><ul><li>new 元素数据类型[高维数组长度] [低维数组长度] ;</li></ul></li></ul></li></ul><h3 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h3><ul><li><p>高维数组元素个数确定，但是低维数组元素个数不同</p></li><li><p>动态初始化不规则数组比较麻烦，初始化4×3二维数组，不能使用new int[4][3]语句，而是先初始化高维数组，然后再分别逐个初始化低维数组</p><ul><li>int intArray[][] = new int[4][]; //先初始化高维数组为4<br>//逐一初始化低维数组<br>intArray[0] = new int[2];<br>intArray[1] = new int[1];<br>intArray[2] = new int[3];<br>intArray[3] = new int[3];</li></ul></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h3><ul><li><p>含义</p><ul><li>Java中的字符串是由双引号括起来的多个字符，Java中的字符采用Unicode编码</li><li>“” 空字符串不是null，空字符串是有分配内存空间的，而null是没有分配内存空间的。</li><li>获得字符串长度方法是length()</li></ul></li><li><p>String（不可变字符串），属于java.lang包，创建String对象可以通过构造方法实现，常用的构造方法</p><ul><li>String()：使用空字符串创建并初始化一个新的String对象。</li><li>String(String original)：使用另外一个字符串创建并初始化一个新的 String 对象。</li><li>String(StringBuffer buffer)：使用可变字符串对象（StringBuffer）创建并初始化一个新的String对象</li><li>String(StringBuilder builder)：使用可变字符串对象（StringBuilder）创建并初始化一个新的String 对象</li><li>String(byte[] bytes)：使用平台的默认字符集解码指定的byte数组，通过byte数组创建并初始化一个新的 String 对象</li><li>String(char[] value)：通过字符数组创建并初始化一个新的 String 对象。</li><li>String(char[] value, int offset, int count)：通过字符数组的子数组创建并初始化一个新的 String 对象；offset参数是子数组第一个字符的索引，count参数指定子数组的长度</li></ul></li><li><p>可变字符串（字符串缓冲区）</p><ul><li><p>StringBuffer（可变字符串）</p><ul><li>StringBuffer是线程安全的，它的方法是支持线程同步 ，线程同步会操作串行顺序执行，在单线程环境下会影响效率。StringBuilder是StringBuffer单线程版本，Java 5之后发布的，它不是线程安全的，但它的执行效率很高。</li></ul></li><li><p>StringBuilder（可变字符串）</p><ul><li>StringBuilder()：创建字符串内容是空的StringBuilder对象，初始容量默认为16个字符。</li><li>StringBuilder(CharSequence seq)：指定CharSequence字符串创建StringBuilder对象。CharSequence接口类型，它的实现类有：String、StringBuffer和StringBuilder等，所以参数seq可以是String、StringBuffer和StringBuilder等类型。</li><li>StringBuilder(int capacity)：创建字符串内容是空的StringBuilder对象，初始容量由参数capacity指定的。</li><li>StringBuilder(String str)：指定String字符串创建StringBuilder对象。</li><li>StringBuilder在提供了很多修改字符串缓冲区的方法，追加、插入、删除和替换等</li></ul></li><li><p>字符串追加</p><ul><li>字符串追加方法是append，append有很多重载方法，可以追加任何类型数据，它的返回值还是StringBuilder</li></ul></li><li><p>字符串插入、删除、替换</p><ul><li>StringBuilder insert(int offset, String str)：在字符串缓冲区中索引为offset的字符位置之前插入str，<br>insert有很多重载方法，可以插入任何类型数据</li><li>StringBuffer delete(int start, int end)：在字符串缓冲区中删除子字符串，要删除的子字符串从指定<br>索引start开始直到索引end - 1处的字符。start和end两个参数与substring(int beginIndex, int<br>endIndex)方法中的两个参数含义一样</li><li>StringBuffer replace(int start, int end, String str)字符串缓冲区中用str替换子字符串，子字符串从指<br>定索引start开始直到索引end - 1处的字符。start和end同delete(int start, int end)方法</li></ul></li></ul></li></ul><h3 id="字符串池"><a href="#字符串池" class="headerlink" title="字符串池"></a>字符串池</h3><ul><li>Java中的不可变字符串String常量，采用字符串池（String Pool）管理技术，字符串池是<br>一种字符串驻留技术</li><li>2个字符串常量赋值同一个值，他们是相同的引用，指向同一个对象</li><li>new关键字创建2个字符串对象，是不同的引用，指向不同的对象</li></ul><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><ul><li><p>字符串拼接</p><ul><li><p>拼接是会产生一个新的对象。</p></li><li><p>String字符串拼接可以使用+运算符或String的concat(String str)方法。</p><ul><li>concat方法定义：public String concat(String str)</li><li>Java中所有对象都有一个toString()方法，该方法可以将对象转换为字符串，拼接过程会调用<br>该对象的toString()方法，将该对象转换为字符串后再进行拼接。</li><li>String的charAt(int index)方法可以返回索引index所在位置的字符</li></ul></li><li><p>+运算符优势是可以连接任何类型数据拼接成为字符串，而concat方法只能拼接String类型字符串。</p></li></ul></li><li><p>字符串查找</p><ul><li><p>indexOf方法</p><ul><li>int indexOf(int ch)：从前往后搜索字符ch，返回第一次找到字符ch所在处的索引。</li><li>int indexOf(int ch, int fromIndex)：从指定的索引开始从前往后搜索字符ch，返回第一次找到字符ch所在处的索引。</li><li>int indexOf(String str)：从前往后搜索字符串str，返回第一次找到字符串所在处的索引。</li><li>int indexOf(String str, int fromIndex)：从指定的索引开始从前往后搜索字符串str，返回第一次找到字符串所在处的索引。</li></ul></li><li><p>lastIndexOf方法</p><ul><li>int lastIndexOf(int ch)：从后往前搜索字符ch，返回第一次找到字符ch所在处的索引。</li><li>int lastIndexOf(int ch, int fromIndex)：从指定的索引开始从后往前搜索字符ch，返回第一次找到字符ch所在处的索引。</li><li>int lastIndexOf(String str)：从后往前搜索字符串str，返回第一次找到字符串所在处的索引。</li><li>int lastIndexOf(String str, int fromIndex)：从指定的索引开始从后往前搜索字符串str，返回第一次找到字符串所在处的索引</li></ul></li></ul></li><li><p>字符串比较</p><ul><li><ol><li>比较相等，String提供的比较字符串相等的方法：</li></ol><ul><li>boolean equals(Object anObject)：比较两个字符串中内容是否相等。</li><li>boolean equalsIgnoreCase(String anotherString)：类似equals方法，只是忽略大小写。</li></ul></li><li><ol start="2"><li>比较大小，有时不仅需要知道是否相等，还要知道大小，String提供的比较大小的方法：</li></ol><ul><li>int compareTo(String anotherString)：按字典顺序比较两个字符串。如果参数字符串等于此字符串，则返回值 0；如果此字符串小于字符串参数，则返回一个小于 0 的值；如果此字符串大于字符串参数，则返回一个大于 0 的值。</li><li>int compareToIgnoreCase(String str)：类似compareTo，只是忽略大小写。</li></ul></li><li><ol start="3"><li>比较前缀和后缀</li></ol><ul><li>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束。</li><li>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始。</li></ul></li></ul></li><li><p>字符串截取</p><ul><li>String substring(int beginIndex)：从指定索引beginIndex开始截取一直到字符串结束的子字符串</li><li>String substring(int beginIndex, int endIndex)：从指定索引beginIndex开始截取直到索引endIndex -1处的字符，注意包括索引为beginIndex处的字符，但不包括索引为endIndex处的字符</li><li>String还提供了字符串分割方法，split(“ “)方法，参数是分割字符串，返回值String[]</li></ul></li></ul><h3 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h3><ul><li><p>Java8在线api文档地址：<a href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a></p></li><li><p>文档页面中各部分的含义</p><ul><li>类和接口中，斜文字体显示是接口，正常字体才是类</li><li>“字段摘要”描述了类中的实例变量和静态变量</li><li>“构造方法摘要”描述了类中所有构造方法</li><li>“方法摘要”描述了类中所有方法</li></ul></li><li><p>查询API的一般流程：找包→找类或接口→查看类或接口→找方法或变量</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础知识&quot;&gt;&lt;a href=&quot;#Java基础知识&quot; class=&quot;headerlink&quot; title=&quot;Java基础知识&quot;&gt;&lt;/a&gt;Java基础知识&lt;/h1&gt;&lt;h2 id=&quot;Java语法基础&quot;&gt;&lt;a href=&quot;#Java语法基础&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Java" scheme="https://zql-gl.github.io/categories/Java/"/>
    
    
    <category term="知识文档" scheme="https://zql-gl.github.io/tags/%E7%9F%A5%E8%AF%86%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>博客与博主</title>
    <link href="https://zql-gl.github.io/posts/1.html"/>
    <id>https://zql-gl.github.io/posts/1.html</id>
    <published>2022-08-20T13:00:00.000Z</published>
    <updated>2022-08-23T14:25:25.998Z</updated>
    
    <content type="html"><![CDATA[<p>相遇皆是缘分</p><h3 id="为什么建博客？"><a href="#为什么建博客？" class="headerlink" title="为什么建博客？"></a>为什么建博客？</h3><p>想拥有一个自己的博客，好进行装逼!</p><h3 id="展望博客"><a href="#展望博客" class="headerlink" title="展望博客"></a>展望博客</h3><p>将一些自己搜集到的资料或学习到的东西整理成博客，上传上来，方便查阅。</p><h3 id="关于博主"><a href="#关于博主" class="headerlink" title="关于博主"></a>关于博主</h3><p>我取名叫从未，这是源于一句话，你喜欢过我吗？– 从未 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> 《自由与爱情》---作者:裴多菲​ 生命诚可贵​ 爱情价更高​ 若为自由故​ 二者皆可抛<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>溜溜球啦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相遇皆是缘分&lt;/p&gt;
&lt;h3 id=&quot;为什么建博客？&quot;&gt;&lt;a href=&quot;#为什么建博客？&quot; class=&quot;headerlink&quot; title=&quot;为什么建博客？&quot;&gt;&lt;/a&gt;为什么建博客？&lt;/h3&gt;&lt;p&gt;想拥有一个自己的博客，好进行装逼!&lt;/p&gt;
&lt;h3 id=&quot;展望博客&quot;&gt;</summary>
      
    
    
    
    <category term="生活" scheme="https://zql-gl.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="想法" scheme="https://zql-gl.github.io/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
</feed>
