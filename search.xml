<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java高级编程</title>
      <link href="/posts/7.html"/>
      <url>/posts/7.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java高级编程"><a href="#Java高级编程" class="headerlink" title="Java高级编程"></a>Java高级编程</h1><h2 id="Java8函数式编程基础–Lambda表达式"><a href="#Java8函数式编程基础–Lambda表达式" class="headerlink" title="Java8函数式编程基础–Lambda表达式"></a>Java8函数式编程基础–Lambda表达式</h2><h3 id="Lambda表达式概述"><a href="#Lambda表达式概述" class="headerlink" title="Lambda表达式概述"></a>Lambda表达式概述</h3><ul><li>Lambda表达式是一个匿名函数（方法）代码块，可以作为表达式、方法参数和方法返回值。</li><li>Lambda表达式标准语法形式如下：(参数列表) -&gt; {<br>//Lambda表达式体<br>}  其中，Lambda表达式参数列表与接口中方法参数列表形式一样，Lambda表达式体实现接口方法。</li></ul><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><ul><li>Lambda表达式实现的接口不是普通的接口，称为是函数式接口，这种接口只能有一个方法。如果接口中声明多个抽象方法，那么Lambda表达式会发生编译错误</li><li>为了防止在函数式接口中声明多个抽象方法，Java 8提供了一个声明函数式接口注解@FunctionalInterface</li></ul><h3 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h3><ul><li><p>访问成员变量</p><ul><li>成员变量包括：实例成员变量和静态成员变量。在Lambda表达式中可以访问这些成员变量，此时的Lambda表达式与普通方法一样，可以读取成员变量，也可以修改成员变量；静态方法中不能访问实例成员变量，实例方法中能够访问静态成员变量和实例成员变量</li></ul></li></ul><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><ul><li>Java 8之后增加了双冒号“::”运算符，该运算符用于“方法引用”，注意不是调用方法。“方法引用”虽然没有直接使用Lambda表达式，但也与Lambda表达式有关，与函数式接口有关。</li><li>方法引用分为：静态方法的方法引用和实例方法的方法引用。它们的语法形式如下：<br>类型名::静态方法 // 静态方法的方法引用<br>实例名::实例方法 // 实例方法的方法引用</li></ul><h2 id="对象容器–集合"><a href="#对象容器–集合" class="headerlink" title="对象容器–集合"></a>对象容器–集合</h2><h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><ul><li><p>集合本质是基于某种数据结构数据容器。常见的数据结构：数组（Array）、集（Set）、队列<br>（Queue）、链表（Linkedlist）、树（Tree）、堆（Heap）、栈（Stack）和映射（Map）等结构。</p></li><li><p>Java集合类型</p><ul><li><p>Collection</p><ul><li><p>Set</p><ul><li>HashSet</li></ul></li><li><p>Queue</p></li><li><p>List</p><ul><li>LinkedList</li><li>ArrayList</li></ul></li></ul></li><li><p>Map</p><ul><li>HashMap</li></ul></li><li><p>Java主要集合接口和类</p><ul><li></li></ul></li></ul></li></ul><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><ul><li><p>概述</p><ul><li>List集合中的元素是有序的，可以重复出现；List集合关心的元素是否有序，而不关心是否重复</li><li>在Java中任何集合中存放的都是对象，即引用数据类型，基本数据类型不能放到集合中。从集合中取出的也是对象</li><li>List接口的实现类有：ArrayList 和LinkedList。ArrayList是基于动态数组数据结构的实现，LinkedList是基于链表数据结构的实现。ArrayList访问元素速度优于LinkedList，LinkedList占用的内存空间比较大，但LinkedList在批量插入或删除数据时优于ArrayList。</li></ul></li><li><p>常用方法</p><ul><li><p>List接口继承自Collection接口，List接口中的很多方法都继承自Collection接口的。List接口中常用方法如下。</p></li><li><ol><li>操作元素</li></ol><ul><li>get(int index)：返回List集合中指定位置的元素。</li><li>set(int index, Object element)：用指定元素替换List集合中指定位置的元素。</li><li>add(Object element)：在List集合的尾部添加指定的元素。该方法是从Collection集合继承<br>过来的。</li><li>add(int index, Object element)：在List集合的指定位置插入指定元素。</li><li>remove(int index)：移除List集合中指定位置的元素。</li><li>remove(Object element)：如果List集合中存在指定元素，则从List集合中移除第一次出现的<br>指定元素。该方法是从Collection集合继承过来的。</li><li>clear()：从List集合中移除所有元素。该方法是从Collection集合继承过来的。</li></ul></li><li><ol start="2"><li>判断元素</li></ol><ul><li>isEmpty()：判断List集合中是否有元素，没有返回true，有返回false。该方法是从<br>Collection集合继承过来的。</li><li>contains(Object element)：判断List集合中是否包含指定元素，包含返回true，不包含返回<br>false。该方法是从Collection集合继承过来的。</li></ul></li><li><ol start="3"><li>查询元素</li></ol><ul><li>indexOf(Object o)：从前往后查找List集合元素，返回第一次出现指定元素的索引，如果此列表不包含该元素，则返回-1。</li><li>lastIndexOf(Object o)：从后往前查找List集合元素，返回第一次出现指定元素的索引，如<br>果此列表不包含该元素，则返回-1。</li></ul></li><li><ol start="4"><li>其他</li></ol><ul><li>iterator()：返回迭代器（Iterator）对象，迭代器对象用于遍历集合。该方法是从Collection<br>集合继承过来的。</li><li>size()：返回List集合中的元素数，返回值是int类型。该方法是从Collection集合继承过来<br>的。</li><li>subList(int fromIndex, int toIndex)：返回List集合中指定的 fromIndex（包括 ）和<br>toIndex（不包括）之间的元素集合，返回值为List集合。</li></ul></li></ul></li><li><p>List遍历集合方法</p><ul><li><ol><li>使用for循环遍历：List集合可以使用for循环进行遍历，for循环中有循环变量，通过循环变量可以访问List集合中的元素。</li></ol></li><li><ol start="2"><li>使用for-each循环遍历：for-each循环是针对遍历各种类型集合而推出的，笔者推荐使用这种遍历方法。</li></ol></li><li><ol start="3"><li>使用迭代器遍历：Java提供了多种迭代器，List集合可以使用Iterator和ListIterator迭代器。</li></ol></li></ul></li></ul><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><ul><li><p>概述</p><ul><li>Set集合是由一串无序的，不能重复的相同类型元素构成的集合</li><li>List集合强调的是有序，Set集合强调的是不重复。当不考虑顺序，且没有重复元素时，Set集合和List集合可以互相替换的。</li><li>Set接口直接实现类主要是HashSet，HashSet是基于散列表数据结构的实现。</li></ul></li><li><p>常用方法</p><ul><li><p>Set接口也继承自Collection接口，Set接口中大部分都是继承自Collection接口，这些方法如下。</p></li><li><ol><li>操作元素</li></ol><ul><li>add(Object element)：在Set集合的尾部添加指定的元素。该方法是从Collection集合继承过<br>来的。</li><li>remove(Object element)：如果Set集合中存在指定元素，则从Set集合中移除该元素。该方<br>法是从Collection集合继承过来的。</li><li>clear()：从Set集合中移除所有元素。该方法是从Collection集合继承过来的。</li></ul></li><li><ol start="2"><li>判断元素</li></ol><ul><li>isEmpty()：判断Set集合中是否有元素，没有返回true，有返回false。该方法是从<br>Collection集合继承过来的。</li><li>contains(Object element)：判断Set集合中是否包含指定元素，包含返回true，不包含返回<br>false。该方法是从Collection集合继承过来的。</li></ul></li><li><ol start="3"><li>其他</li></ol><ul><li>iterator()：返回迭代器（Iterator）对象，迭代器对象用于遍历集合。该方法是从Collection<br>集合继承过来的。</li><li>size()：返回Set集合中的元素数，返回值是int类型。该方法是从Collection集合继承过来<br>的。</li></ul></li></ul></li><li><p>Set遍历集合的方法</p><ul><li>for-each循环，推荐使用</li><li>迭代器</li></ul></li></ul><h3 id="Map（映射）集合"><a href="#Map（映射）集合" class="headerlink" title="Map（映射）集合"></a>Map（映射）集合</h3><ul><li><p>概述</p><ul><li>Map（映射）集合表示一种非常复杂的集合，允许按照某个键来访问元素。Map集合是由两个集合构成的，一个是键（key）集合，一个是值（value）集合。键集合是Set类型，因此不能有重复的元素。而值集合是Collection类型，可以有重复的元素。Map集合中的键和值是成对出现的。</li><li>Map接口直接实现类主要是HashMap，HashMap是基于散列表数据结构的实现。</li></ul></li><li><p>常用方法</p><ul><li><ol><li>操作元素</li></ol><ul><li>get(Object key)：返回指定键所对应的值；如果Map集合中不包含该键值对，则返回null。</li><li>put(Object key, Object value)：指定键值对添加到集合中。</li><li>remove(Object key)：移除键值对。</li><li>clear()：移除Map集合中所有键值对。</li></ul></li><li><ol start="2"><li>判断元素</li></ol><ul><li>isEmpty()：判断Map集合中是否有键值对，没有返回true，有返回false。</li><li>containsKey(Object key)：判断键集合中是否包含指定元素，包含返回true，不包含返回<br>false。</li><li>containsValue(Object value)：判断值集合中是否包含指定元素，包含返回true，不包含返<br>回false。</li></ul></li><li><ol start="3"><li>查看集合</li></ol><ul><li>keySet()：返回Map中的所有键集合，返回值是Set类型。</li><li>values()：返回Map中的所有值集合，返回值是Collection类型。</li><li>size()：返回Map集合中键值对数。</li></ul></li></ul></li><li><p>遍历集合方法</p><ul><li>Map集合遍历与List和Set集合不同，Map有两个集合，因此遍历时可以只遍历值的集合，也可以只遍历键的集合，也可以同时遍历。这些遍历过程都可以使用for-each循环和迭代器进行遍历。推荐使用for-each循环</li></ul></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>异常类继承层次</p><ul><li></li></ul></li><li><p>Throwable类</p><ul><li>所有的异常类都直接或间接地继承于java.lang.Throwable类，在Throwable类有几个非常重要的方法：</li><li>String getMessage()：获得发生异常的详细消息。</li><li>void printStackTrace()：打印异常堆栈跟踪信息。</li><li>String toString()：获得异常对象的描述。</li></ul></li><li><p>Error类</p><ul><li>Error是程序无法恢复的严重错误，程序员根本无能为力，只能让程序终止。例如：JVM内部错<br>误、内存溢出和资源耗尽等严重情况</li></ul></li><li><p>Exception类</p><ul><li><p>Exception是程序可以恢复的异常，它是程序员所能掌控的。例如：除零异常、空指针访问、网<br>络连接中断和读取不存在的文件等。</p></li><li><p>受检查异常</p><ul><li>受检查异常是除RuntimeException以外的异常类。它们的共同特点是：编译器会检查这类异常是否进行了处理，即要么捕获（try-catch句），要么不抛出（通过在方法后声throws），否则会发生编译错误</li></ul></li><li><p>运行时异常</p><ul><li>运行时异常是继承RuntimeException类的直接或间接子类。运行时异常往往是程序员所犯错误导致的，健壮的程序不应该发生运行时异常。它们的共同特点是：编译器不检查这类异常是否进<br>行了处理，也就是对于这类异常不捕获也不抛出，程序也可以编译通过。由于没有进行异常处<br>理，一旦运行时异常发生就会导致程序的终止</li></ul></li></ul></li></ul><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><ul><li><p>try-catch语句</p><ul><li><p>捕获异常是通过try-catch语句实现的，最基本try-catch语句语法如下：try{<br>//可能会发生异常的语句<br>} catch(Throwable e){<br>//处理异常e<br>}</p></li><li><p>try代码块</p><ul><li>try代码块中应该包含执行过程中可能会发生异常的语句。</li><li>静态方法、实例方法和构造方法都可以声明抛出异常，凡是抛出异常的方法都可以通过try-catch进行捕获，当然运行时异常可以不捕获</li></ul></li><li><p>catch代码块</p><ul><li>每个try代码块可以伴随一个或多个catch代码块，用于处理try代码块中所可能发生的多种异常</li></ul></li><li><p>多catch代码块</p><ul><li>如果try代码块中有很多语句会发生异常，而且发生的异常种类又很多。那么可以在try后面跟有多个catch代码块。多catch代码块语法如下：<br>try{<br>//可能会发生异常的语句<br>} catch(Throwable e){<br>//处理异常e<br>} catch(Throwable e){<br>//处理异常e<br>} catch(Throwable e){<br>//处理异常e<br>}     在多个catch代码情况下，当一个catch代码块捕获到一个异常时，其他的catch代码块就不再进行匹配。当捕获的多个异常类之间存在父子关系时，捕获异常顺序与catch代码块的顺序有关。一般先捕获子类，后捕获父类，否则子类捕获不到。</li></ul></li><li><p>try-catch语句嵌套</p><ul><li>Java提供的try-catch语句嵌套是可以任意嵌套</li></ul></li><li><p>多重抓捕multi-catch</p><ul><li>如果有些异常虽然种类不同，但捕获之后的处理是相同的，使用多重抓捕可以将异常合并处理；在catch中多重捕获异常用“|”运算符连接起来。</li></ul></li></ul></li></ul><h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><ul><li><p>finally代码块</p><ul><li>try-catch语句后面还可以跟有一个finally代码块，try-catch-finally语句语法如下：</li><li>try{<br>//可能会生成异常语句<br>} catch(Throwable e1){<br>//处理异常e1<br>} catch(Throwable e2){<br>//处理异常e2<br>} catch(Throwable eN){<br>//处理异常eN<br>} finally{<br>//释放资源<br>}     无论try正常结束还是catch异常结束都会执行finally代码块</li></ul></li><li><p>自动资源管理</p><ul><li>自动资源管理是在try语句上的扩展，语法如下：try (声明或初始化资源语句) {<br>//可能会生成异常语句<br>} catch(Throwable e1){<br>//处理异常e1<br>} catch(Throwable e2){<br>//处理异常e1<br>} catch(Throwable eN){<br>//处理异常eN<br>}</li></ul></li></ul><h3 id="throws与声明方法抛出异常"><a href="#throws与声明方法抛出异常" class="headerlink" title="throws与声明方法抛出异常"></a>throws与声明方法抛出异常</h3><ul><li>方法中可能抛出的异常（除了Error和<br>RuntimeException及其子类外）都必须通过throws语句列出，多个异常之间采用逗号（,）分隔。</li></ul><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><ul><li>实现自定义异常类需要继承Exception类或其子类，如果自定义运行时异常类需继承<br>RuntimeException类或其子类。</li><li>自定义异常类一般需要提供两个构造方法，一个是无参数的默认构造方法，异常描述信息是空的；另一个是字符串参数的构造方法，message是异常描述信息，getMessage()方法可以获得这些信息</li></ul><h3 id="throw与显示抛出异常"><a href="#throw与显示抛出异常" class="headerlink" title="throw与显示抛出异常"></a>throw与显示抛出异常</h3><ul><li>throws用于方法后声明抛出异常，而throw关键字用来人工引发异常，通过throw语句显式抛出异常，语法格式如下：throw Throwable或其子类的实例     所有Throwable或其子类的实例都可以通过throw语句抛出。</li></ul><h2 id="泛型（Generics）"><a href="#泛型（Generics）" class="headerlink" title="泛型（Generics）"></a>泛型（Generics）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>泛型对于Java影响最大就是集合了，Java 5之后所有的集合类型都可以有泛型类型，可以限定存放到集合中的类型，例如：List<string> list = new ArrayList<string>();   尖括号中可以任何的引用类型，它限定了集合中是能存放该种类型的对象</string></string></li></ul><h3 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h3><ul><li>泛型中参数类型占位符，可以是任何大写或小写的英文字母，一般情况下人们习惯于使用<br>字母T、E、K和U等大写英文字母，但也可以使用其他的字母。例如：public class Queue<t>{}</t></li><li>自定义泛型类时可能会用到多个类型参数，可以使用多个不同的字母作为占位符，类似于<br>Map&lt;K,V&gt;</li></ul><h3 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h3><ul><li>public interface IQueue<t> {}</t></li><li>需要注意的是实现泛型接口的具体类也应该支持泛型，所以Queue<t>中类型参数名要与IQueue<t>接口中的类型参数名一致，占位符所用字母相同。</t></t></li></ul><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul><li>在方法中也可以使用泛型，即方法的参数类型或返回值类型，可以用类型参数表示。</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h3><ul><li><p>@Override</p><ul><li>@Override只能用于方法，子类覆盖父类方法（或者实现接口的方法）时可以@Override注解。编译器会检查被@Override注解的方法，确保该方法父类中存在的方法，否则会有编译错误。</li></ul></li><li><p>@Deprecated</p><ul><li>@Deprecated用来指示API已经过时了,@Deprecated可以用来注解类、接口、成员方法和成员变量。</li></ul></li><li><p>@SuppressWarnings</p><ul><li>@SuppressWarnings注解用来抑制编译器警告，如果你确认程序中的警告没有问题，可以不用理会。但是就是不想看到这些警告，可以使用@SuppressWarnings注解消除这些警告。</li></ul></li><li><p>@FunctionalInterface</p><ul><li>用于接口的注解，声明接口是函数式接口</li></ul></li><li><p>@SafeVarargs</p></li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul><li><p>@Documented</p><ul><li>如果在一个自定义注解中引用@Documented注解，那么该注解可以修饰代码元素（类、接口、<br>成员变量和成员方法等），javadoc等工具可以提取这些注解信息。</li></ul></li><li><p>@Target</p><ul><li>@Target注解用来指定一个新注解的适用目标。@Target注解有一个成员（value）用来设置适用目标</li></ul></li><li><p>@Retention</p><ul><li>@Retention注解用来指定一个新注解的有效范围，@Retention注解有一个成员（value）用来设置保留策略</li></ul></li><li><p>@Inherited</p><ul><li>@Inherited注解用来指定一个新注解可以被继承。假定一个类A被该新注解修饰，那么这个A类<br>的子类会继承该新注解。</li></ul></li><li><p>@Repeatable</p><ul><li>@Repeatable注解是Java 8新增加的，它允许在相同的程序元素中重复注释，可重复的注释必须<br>使用@Repeatable进行注释</li></ul></li><li><p>@Native</p><ul><li>@Native注解一个成员变量，指示这个变量可以被本地代码引用。常常被代码生成工具使用。</li></ul></li></ul><h2 id="文件管理与I-O流"><a href="#文件管理与I-O流" class="headerlink" title="文件管理与I/O流"></a>文件管理与I/O流</h2><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ul><li><p>File类</p><ul><li><p>File类表示一个与平台无关的文件或目录，File类中的常用方法：</p></li><li><ol><li>构造方法</li></ol><ul><li>File(String path)：如果path是实际存在的路径，则该File对象表示的是目录；如果path是文<br>件名，则该File对象表示的是文件。</li><li>File(String path, String name)：path是路径名，name是文件名。</li><li>File(File dir, String name)：dir是路径对象，name是文件名。</li></ul></li><li><ol start="2"><li>获得文件名</li></ol><ul><li>String getName( )：获得文件的名称，不包括路径。</li><li>String getPath( )：获得文件的路径。</li><li>String getAbsolutePath( )：获得文件的绝对路径。</li><li>String getParent( )：获得文件的上一级目录名。</li></ul></li><li><ol start="3"><li>文件属性测试</li></ol><ul><li>boolean exists( )：测试当前File对象所表示的文件是否存在。</li><li>boolean canWrite( )：测试当前文件是否可写。</li><li>boolean canRead( )：测试当前文件是否可读。</li><li>boolean isFile( )：测试当前文件是否是文件。</li><li>boolean isDirectory( )：测试当前文件是否是目录。</li></ul></li><li><ol start="4"><li>文件操作</li></ol><ul><li>long lastModified( )：获得文件最近一次修改的时间。</li><li>long length( )：获得文件的长度，以字节为单位。</li><li>boolean delete( )：删除当前文件。成功返回 true，否则返回false。</li><li>boolean renameTo(File dest)：将重新命名当前File对象所表示的文件。成功返回 true，否<br>则返回false。</li></ul></li><li><ol start="5"><li>目录操作</li></ol><ul><li>boolean mkdir( )：创建当前File对象指定的目录。</li><li>String[] list()：返回当前目录下的文件和目录，返回值是字符串数组。</li><li>String[] list(FilenameFilter filter)：返回当前目录下满足指定过滤器的文件和目录，参数是实现FilenameFilter接口对象，返回值是字符串数组。</li><li>File[] listFiles()：返回当前目录下的文件和目录，返回值是File数组。</li><li>File[] listFiles(FilenameFilter filter)：返回当前目录下满足指定过滤器的文件和目录，参数是实现FilenameFilter接口对象，返回值是File数组。</li><li>File[] listFiles(FileFilter filter)：返回当前目录下满足指定过滤器的文件和目录，参数是实<br>现FileFilter接口对象，返回值是File数组。</li></ul></li></ul></li></ul><h3 id="I-O流（Input-Output）"><a href="#I-O流（Input-Output）" class="headerlink" title="I/O流（Input/Output）"></a>I/O流（Input/Output）</h3><ul><li><p>概述</p><ul><li>Java将数据的输入输出（I/O）操作当作“流”来处理，“流”是一组有序的数据序列。“流”分为两种形<br>式：输入流和输出流，从数据源中读取数据是输入流，将数据写入到目的地是输出流。</li><li>键盘是默认的标准输入设备</li><li>控制台是默认的标准输出设备。</li></ul></li><li><p>流类继承层次</p><ul><li><p>字节流抽象类</p><ul><li><p>InputStream(根类)</p><ul><li><p>FileInputStream（文件输入流）</p></li><li><p>ByteArrayInputStream（面向字节数组的输入流）</p></li><li><p>PipedInputStream（管道输入流，用于两个线程之间的数据传递）</p></li><li><p>FilterInputStream（过滤输入流，它是一个装饰器扩展其他输入流）</p><ul><li>BufferedInputStream（缓冲区输入流）</li><li>DataInputStream（面向基本数据类型的输入流）</li></ul></li></ul></li><li><p>OutputStream(根类)</p><ul><li><p>FileOutputStream（文件输出流）</p></li><li><p>ByteArrayOutputStream（面向字节数组的输出流）</p></li><li><p>PipedOutputStream（管道输出流，用于两个线程之间的数据传递）</p></li><li><p>FilterOutputStream（过滤输出流，它是一个装饰器扩展其他输出流）</p><ul><li>BufferedOutputStream（缓冲区输出流）</li><li>DataOutputStream（面向基本数据类型的输出流）</li></ul></li></ul></li></ul></li><li><p>字符流抽象类</p><ul><li><p>Reader(根类)</p><ul><li><p>CharArrayReader（面向字节数组的输入流）</p></li><li><p>PipedReader（管道输入流，用于两个线程之间的数据传递）</p></li><li><p>FilterReader（过滤输入流，它是一个装饰器扩展其他输入流）</p></li><li><p>BufferedReader（缓冲区输入流，他是一个装饰器，不是FilterReader的子类）</p></li><li><p>InputStreamReader（把字节流转换为字符流，是FileReader的父类）</p><ul><li>FileReader（文件输入流）</li></ul></li></ul></li><li><p>Writer(根类)</p><ul><li><p>CharArrayWriter（面向字节数组的输出流）</p></li><li><p>PipedWriter（管道输出流，用于两个线程之间的数据传递）</p></li><li><p>FilterWriter（过滤输出流，它是一个装饰器扩展其他输入流）</p></li><li><p>BufferedWriter（缓冲区输出流，他是一个装饰器，不是FilterWriter的子类）</p></li><li><p>OutputStreamWriter（把字节流转换为字符流，是FileWriter的父类）</p><ul><li>FileWriter（文件输出流）</li></ul></li></ul></li></ul></li></ul></li><li><p>字节流</p><ul><li><p>InputStream抽象类主要方法</p><ul><li>int read()：读取一个字节，返回0到255范围内的int字节值。如果已经到达流末尾，而且没有可用的字节，则返回值-1。</li><li>int read(byte b[] )：读取多个字节，数据放到字节数组b中，返回值为实际读取的字节的数量，如果已经到达流末尾，而且没有可用的字节，则返回值-1。</li><li>int read(byte b[ ], int off, int len)：最多读取len个字节，数据放到以下标off开始字节数组b中，将读取的第一个字节存储在元素b[off]中，下一个存储在b[off+1]中，依次类推。返回值为实际读取的字节的数量，如果已经到达流末尾，而且没有可用的字节，则返回值-1。</li><li>void close()：流操作完毕后必须关闭。</li></ul></li><li><p>OutputStream抽象类主要方法</p><ul><li>void write(int b)：将b写入到输出流，b是int类型占有32位，写入过程是写入b 的8个低位，b的24个高位将被忽略。</li><li>void write(byte b[ ])：将b.length个字节从指定字节数组b写入到输出流。</li><li>void write(byte b[ ], int off, int len)：把字节数组b中从下标off开始，长度为len的字节写入到输出流。</li><li>void flush()：刷空输出流，并输出所有被缓存的字节。由于某些流支持缓存功能，该方法将把缓存中所有内容强制输出到流中。</li><li>void close( )：流操作完毕后必须关闭。</li></ul></li></ul></li><li><p>字符流</p><ul><li><p>Reader抽象类主要方法</p><ul><li>int read()：读取一个字符，返回值范围在0<del>65535(0x00</del>0xffff)之间。如果因为已经到达流末尾，则返回值-1。</li><li>int read(char[] cbuf)：将字符读入到数组cbuf中，返回值为实际读取的字符的数量，如果因为已经到达流末尾，则返回值-1。</li><li>int read(char[] cbuf, int off, int len)：最多读取len个字符，数据放到以下标off开始字符数组cbuf中，将读取的第一个字符存储在元素cbuf[off]中，下一个存储在cbuf[off+1]中，依次类推。返回值为实际读取的字符的数量，如果因为已经到达流末尾，则返回值-1。</li><li>void close()：流操作完毕后必须关闭。</li></ul></li><li><p>Writer抽象类主要方法</p><ul><li>void write(int c)：将整数值为c的字符写入到输出流，c是int类型占有32位，写入过程是写入c的16个低位，c的16个高位将被忽略。</li><li>void write(char[] cbuf)：将字符数组cbuf写入到输出流。</li><li>void write(char[] cbuf, int off, int len)：把字符数组cbuf中从下标off开始，长度为len的字符写入到输出流。</li><li>void write(String str)：将字符串str中的字符写入输出流。</li><li>void write(String str,int off,int len)：将字符串str 中从索引off开始处的len个字符写入输出流。</li><li>void flush()：刷空输出流，并输出所有被缓存的字符。由于某些流支持缓存功能，该方法将把缓存中所有内容强制输出到流中。</li><li>void close( )：流操作完毕后必须关闭。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP响应状态码</title>
      <link href="/posts/8.html"/>
      <url>/posts/8.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h1><h2 id="1开头的类型：该类型状态码表示接收到请求并且继续处理。"><a href="#1开头的类型：该类型状态码表示接收到请求并且继续处理。" class="headerlink" title="1开头的类型：该类型状态码表示接收到请求并且继续处理。"></a>1开头的类型：该类型状态码表示接收到请求并且继续处理。</h2><h3 id="100，客户端必须继续发出请求。"><a href="#100，客户端必须继续发出请求。" class="headerlink" title="100，客户端必须继续发出请求。"></a>100，客户端必须继续发出请求。</h3><h3 id="101，客户端要求服务器根据请求转换HTTP协议版本。"><a href="#101，客户端要求服务器根据请求转换HTTP协议版本。" class="headerlink" title="101，客户端要求服务器根据请求转换HTTP协议版本。"></a>101，客户端要求服务器根据请求转换HTTP协议版本。</h3><h2 id="2开头的类型：该类型状态码表示动作被成功接收、理解和接受。"><a href="#2开头的类型：该类型状态码表示动作被成功接收、理解和接受。" class="headerlink" title="2开头的类型：该类型状态码表示动作被成功接收、理解和接受。"></a>2开头的类型：该类型状态码表示动作被成功接收、理解和接受。</h2><h3 id="200，表明该请求被成功地完成，所请求的资源发送到客户端。"><a href="#200，表明该请求被成功地完成，所请求的资源发送到客户端。" class="headerlink" title="200，表明该请求被成功地完成，所请求的资源发送到客户端。"></a>200，表明该请求被成功地完成，所请求的资源发送到客户端。</h3><h3 id="201，提示知道新文件的URL。"><a href="#201，提示知道新文件的URL。" class="headerlink" title="201，提示知道新文件的URL。"></a>201，提示知道新文件的URL。</h3><h3 id="202，接受并处理，但处理未完成。"><a href="#202，接受并处理，但处理未完成。" class="headerlink" title="202，接受并处理，但处理未完成。"></a>202，接受并处理，但处理未完成。</h3><h3 id="203，返回信息不确定或不完整。"><a href="#203，返回信息不确定或不完整。" class="headerlink" title="203，返回信息不确定或不完整。"></a>203，返回信息不确定或不完整。</h3><h3 id="204，收到请求，但返回信息为空。"><a href="#204，收到请求，但返回信息为空。" class="headerlink" title="204，收到请求，但返回信息为空。"></a>204，收到请求，但返回信息为空。</h3><h3 id="205，服务器完成了请求，用户必须复位当前已经浏览过的文件。"><a href="#205，服务器完成了请求，用户必须复位当前已经浏览过的文件。" class="headerlink" title="205，服务器完成了请求，用户必须复位当前已经浏览过的文件。"></a>205，服务器完成了请求，用户必须复位当前已经浏览过的文件。</h3><h3 id="206，服务器已经完成了部分用户的GET请求。"><a href="#206，服务器已经完成了部分用户的GET请求。" class="headerlink" title="206，服务器已经完成了部分用户的GET请求。"></a>206，服务器已经完成了部分用户的GET请求。</h3><h2 id="3开头的类型：该类型状态码表示为了完成指定的动作，必须接受进一步处理。"><a href="#3开头的类型：该类型状态码表示为了完成指定的动作，必须接受进一步处理。" class="headerlink" title="3开头的类型：该类型状态码表示为了完成指定的动作，必须接受进一步处理。"></a>3开头的类型：该类型状态码表示为了完成指定的动作，必须接受进一步处理。</h2><h3 id="300，请求的资源可在多处获得。"><a href="#300，请求的资源可在多处获得。" class="headerlink" title="300，请求的资源可在多处获得。"></a>300，请求的资源可在多处获得。</h3><h3 id="301，本网页被永久性转移到另一个URL。"><a href="#301，本网页被永久性转移到另一个URL。" class="headerlink" title="301，本网页被永久性转移到另一个URL。"></a>301，本网页被永久性转移到另一个URL。</h3><h3 id="302，请求的网页被重定向到新的地址。"><a href="#302，请求的网页被重定向到新的地址。" class="headerlink" title="302，请求的网页被重定向到新的地址。"></a>302，请求的网页被重定向到新的地址。</h3><h3 id="303，建议用户访问其他URL或访问方式。"><a href="#303，建议用户访问其他URL或访问方式。" class="headerlink" title="303，建议用户访问其他URL或访问方式。"></a>303，建议用户访问其他URL或访问方式。</h3><h3 id="304，自从上次请求后，请求的网页未修改过。"><a href="#304，自从上次请求后，请求的网页未修改过。" class="headerlink" title="304，自从上次请求后，请求的网页未修改过。"></a>304，自从上次请求后，请求的网页未修改过。</h3><h3 id="305，请求的资源必须从服务器指定的地址获得。"><a href="#305，请求的资源必须从服务器指定的地址获得。" class="headerlink" title="305，请求的资源必须从服务器指定的地址获得。"></a>305，请求的资源必须从服务器指定的地址获得。</h3><h3 id="306，前一版本HTTP中使用的代码，现已不再使用。"><a href="#306，前一版本HTTP中使用的代码，现已不再使用。" class="headerlink" title="306，前一版本HTTP中使用的代码，现已不再使用。"></a>306，前一版本HTTP中使用的代码，现已不再使用。</h3><h3 id="307，声明请求的资源临时性删除。"><a href="#307，声明请求的资源临时性删除。" class="headerlink" title="307，声明请求的资源临时性删除。"></a>307，声明请求的资源临时性删除。</h3><h2 id="4开头的类型：该类型状态码表示请求包含错误语法或不能正确执行。"><a href="#4开头的类型：该类型状态码表示请求包含错误语法或不能正确执行。" class="headerlink" title="4开头的类型：该类型状态码表示请求包含错误语法或不能正确执行。"></a>4开头的类型：该类型状态码表示请求包含错误语法或不能正确执行。</h2><h3 id="400，客户端请求有语法错误。"><a href="#400，客户端请求有语法错误。" class="headerlink" title="400，客户端请求有语法错误。"></a>400，客户端请求有语法错误。</h3><h3 id="401，请求未经授权。"><a href="#401，请求未经授权。" class="headerlink" title="401，请求未经授权。"></a>401，请求未经授权。</h3><h3 id="402，保留有效ChargeTo头响应。"><a href="#402，保留有效ChargeTo头响应。" class="headerlink" title="402，保留有效ChargeTo头响应。"></a>402，保留有效ChargeTo头响应。</h3><h3 id="403，禁止访问，服务器收到请求，但拒绝提供服务。"><a href="#403，禁止访问，服务器收到请求，但拒绝提供服务。" class="headerlink" title="403，禁止访问，服务器收到请求，但拒绝提供服务。"></a>403，禁止访问，服务器收到请求，但拒绝提供服务。</h3><h3 id="404，可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。"><a href="#404，可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。" class="headerlink" title="404，可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。"></a>404，可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。</h3><h3 id="405，用户在Request-Line字段定义的方法不被允许。"><a href="#405，用户在Request-Line字段定义的方法不被允许。" class="headerlink" title="405，用户在Request-Line字段定义的方法不被允许。"></a>405，用户在Request-Line字段定义的方法不被允许。</h3><h3 id="406，根据用户发送的Accept，请求资源不可访问。"><a href="#406，根据用户发送的Accept，请求资源不可访问。" class="headerlink" title="406，根据用户发送的Accept，请求资源不可访问。"></a>406，根据用户发送的Accept，请求资源不可访问。</h3><h3 id="407，类似401，用户必须首先在代理服务器上取得授权。"><a href="#407，类似401，用户必须首先在代理服务器上取得授权。" class="headerlink" title="407，类似401，用户必须首先在代理服务器上取得授权。"></a>407，类似401，用户必须首先在代理服务器上取得授权。</h3><h3 id="408，客户端没有在用户指定的时间内完成请求。"><a href="#408，客户端没有在用户指定的时间内完成请求。" class="headerlink" title="408，客户端没有在用户指定的时间内完成请求。"></a>408，客户端没有在用户指定的时间内完成请求。</h3><h3 id="409，对当前资源状态，请求不能完成。"><a href="#409，对当前资源状态，请求不能完成。" class="headerlink" title="409，对当前资源状态，请求不能完成。"></a>409，对当前资源状态，请求不能完成。</h3><h3 id="410，服务器上不再有此资源。"><a href="#410，服务器上不再有此资源。" class="headerlink" title="410，服务器上不再有此资源。"></a>410，服务器上不再有此资源。</h3><h3 id="411，服务器拒绝用户定义的Content-Length属性请求。"><a href="#411，服务器拒绝用户定义的Content-Length属性请求。" class="headerlink" title="411，服务器拒绝用户定义的Content-Length属性请求。"></a>411，服务器拒绝用户定义的Content-Length属性请求。</h3><h3 id="412，一个或多个请求头字段在当前请求中错误。"><a href="#412，一个或多个请求头字段在当前请求中错误。" class="headerlink" title="412，一个或多个请求头字段在当前请求中错误。"></a>412，一个或多个请求头字段在当前请求中错误。</h3><h3 id="413，请求的资源大于服务器允许的大小。"><a href="#413，请求的资源大于服务器允许的大小。" class="headerlink" title="413，请求的资源大于服务器允许的大小。"></a>413，请求的资源大于服务器允许的大小。</h3><h3 id="414，请求的资源URL长于服务器允许的长度。"><a href="#414，请求的资源URL长于服务器允许的长度。" class="headerlink" title="414，请求的资源URL长于服务器允许的长度。"></a>414，请求的资源URL长于服务器允许的长度。</h3><h3 id="415，请求资源不支持请求项目格式。"><a href="#415，请求资源不支持请求项目格式。" class="headerlink" title="415，请求资源不支持请求项目格式。"></a>415，请求资源不支持请求项目格式。</h3><h3 id="416，请求中包含Range请求头字段，在当前请求资源范围内没有range指示值。"><a href="#416，请求中包含Range请求头字段，在当前请求资源范围内没有range指示值。" class="headerlink" title="416，请求中包含Range请求头字段，在当前请求资源范围内没有range指示值。"></a>416，请求中包含Range请求头字段，在当前请求资源范围内没有range指示值。</h3><h3 id="417，服务器不满足请求Expect头字段指定的期望值。"><a href="#417，服务器不满足请求Expect头字段指定的期望值。" class="headerlink" title="417，服务器不满足请求Expect头字段指定的期望值。"></a>417，服务器不满足请求Expect头字段指定的期望值。</h3><h2 id="5开头的类型：该类型状态码表示服务器或网关错误。"><a href="#5开头的类型：该类型状态码表示服务器或网关错误。" class="headerlink" title="5开头的类型：该类型状态码表示服务器或网关错误。"></a>5开头的类型：该类型状态码表示服务器或网关错误。</h2><h3 id="500，服务器错误。"><a href="#500，服务器错误。" class="headerlink" title="500，服务器错误。"></a>500，服务器错误。</h3><h3 id="501，服务器不支持请求的功能。"><a href="#501，服务器不支持请求的功能。" class="headerlink" title="501，服务器不支持请求的功能。"></a>501，服务器不支持请求的功能。</h3><h3 id="502，网关错误。"><a href="#502，网关错误。" class="headerlink" title="502，网关错误。"></a>502，网关错误。</h3><h3 id="503，无法获得服务。"><a href="#503，无法获得服务。" class="headerlink" title="503，无法获得服务。"></a>503，无法获得服务。</h3><h3 id="504，网关超时。"><a href="#504，网关超时。" class="headerlink" title="504，网关超时。"></a>504，网关超时。</h3><h3 id="505，不支持的http版本。"><a href="#505，不支持的http版本。" class="headerlink" title="505，不支持的http版本。"></a>505，不支持的http版本。</h3>]]></content>
      
      
      <categories>
          
          <category> 网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法的介绍</title>
      <link href="/posts/9.html"/>
      <url>/posts/9.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法的介绍"><a href="#Markdown语法的介绍" class="headerlink" title="Markdown语法的介绍"></a>Markdown语法的介绍</h1><h2 id="无序列表：‘-’-‘-’-空格"><a href="#无序列表：‘-’-‘-’-空格" class="headerlink" title="无序列表：‘+’/‘-’+空格"></a>无序列表：‘+’/‘-’+空格</h2><p>有序列表：数字+英文的点+空格</p><h2 id="标题：使用‘-’号-空格-表示标题，写完后回车，几个‘-’号就是几级标题，最高为六级标题"><a href="#标题：使用‘-’号-空格-表示标题，写完后回车，几个‘-’号就是几级标题，最高为六级标题" class="headerlink" title="标题：使用‘#’号+空格 表示标题，写完后回车，几个‘#’号就是几级标题，最高为六级标题"></a>标题：使用‘#’号+空格 表示标题，写完后回车，几个‘#’号就是几级标题，最高为六级标题</h2><h2 id="加粗：Ctrl-B"><a href="#加粗：Ctrl-B" class="headerlink" title="加粗：Ctrl+B /** **"></a>加粗：Ctrl+B /** **</h2><p>斜体：* *<br>加粗斜体：*** ***<br>进入源代码格式：Ctrl+/</p><h2 id="gt-空格表示说明"><a href="#gt-空格表示说明" class="headerlink" title=">+空格表示说明"></a>&gt;+空格表示说明</h2><h2 id="插入超链接：名字回车"><a href="#插入超链接：名字回车" class="headerlink" title="插入超链接：名字回车"></a>插入超链接：<a href="%E5%9C%B0%E5%9D%80%E9%93%BE%E6%8E%A5">名字</a>回车</h2><h2 id="插入图片：！回车"><a href="#插入图片：！回车" class="headerlink" title="插入图片：！回车"></a>插入图片：！<a href="%E5%9B%BE%E7%89%87%E7%9A%84%E4%BD%8D%E7%BD%AE"></a>回车</h2><h2 id="写代码：-语言类型"><a href="#写代码：-语言类型" class="headerlink" title="写代码：```+语言类型"></a>写代码：```+语言类型</h2><pre><code class="Python：这个就是写Python代码">## 原封不动的显示内容：`这里的东西原封不动显示`，用一对``来包围</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象</title>
      <link href="/posts/3.html"/>
      <url>/posts/3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="三个基本特性"><a href="#三个基本特性" class="headerlink" title="三个基本特性"></a>三个基本特性</h3><ul><li><p>封装</p><ul><li>封装能够使外部访问者不能随意存取对象的内部<br>数据，隐藏了对象的内部细节，只保留有限的对外接口。外部访问者不用关心对象的内部细节，使得操作对象变得简单</li></ul></li><li><p>继承</p><ul><li>在Java语言中一般类称为“父类”，特殊类称为“子类”。Java语言是单继承的，即只能有一个父类，但Java可以实现多个接口，可以防止多继承所引起的冲突问题</li></ul></li><li><p>多态</p><ul><li>多态性是指在父类中成员变量和成员方法被子类继承之后，可以具有不同的状态或表现行为</li></ul></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li><p>类是Java中的一种重要的引用数据类型，是组成Java程序的基本要素。它封装了一类对象的数据和操作。</p></li><li><p>Java语言中一个类的实现包括：类声明和类体。类声明语法格式如下：<br>[public][abstract|final] class className [extends superclassName] [implements interfaceNameList] {<br>//类体<br>}</p><ul><li>class是声明类的关键字，className是自定义的类名；class前面的修饰符public、abstract、final用来声明类，它们可以省略，它们的具体用法后面章节会详细介绍；superclassName为父类名，可以省略，如果省略则该类继承Object类，Object类所有类的根类，所有类都直接或间接继承Object；interfaceNameList是该类实现的接口列表，可以省略，接口列表中的多个接口之间用逗号分隔</li><li>类体是类的主体，包括数据和操作，即成员变量和成员方法。</li></ul></li><li><p>成员变量</p><ul><li>声明类体中成员变量语法格式如下：<br>class className {<br>[public | protected | private ] [static] [final] type variableName; //成员变量<br>}</li></ul></li></ul><pre><code>    - type是成员变量数据类型，variableName是成员变量名。type前的关键字都是成员变量修饰符，它们说明如下：    - 01. public、protected和private修饰符用于封装成员变量。    - 02. static修饰符用于声明静态变量，所以静态变量也称为“类变量”。    - 03. final修饰符用于声明变量，该变量不能被修改</code></pre><ul><li><p>成员方法</p><ul><li>声明类体中成员方法语法格式如下：class className {<br>[public | protected | private ] [static] [final | abstract] [native] [synchronized]<br>type methodName([paramList]) [throws exceptionList] {<br>//方法体<br>}<br>}</li></ul></li></ul><pre><code>    - type是方法返回值数据类型，methodName是方法名。type前的关键字都是方法修饰符，它们说明如下：    - 01. public、protected和private修饰符用于封装方法。    - 02. static修饰符用于声明静态方法，所以静态方法也称为“类方法”。    - 03. final | abstract不能同时修饰方法，final修饰的方法不能在子类中被覆盖；abstract用来修饰抽象方法，抽象方法必须在子类中被实现。    - 04. native修饰的方法，称为“本地方法”，本地方法调用平台本地代码（如：C或C++编写的代</code></pre><p>码），不能实现跨平台。<br>        - 05. synchronized修饰的方法是同步的，当多线程方式同步方法时，只能串行地执行，保证是线程安全的。<br>        - 06.方法声明中还有([paramList])部分，它是方法的参数列表。throws exceptionList是声明抛出异常列表。</p><pre><code>- 如果方法返回值类型为void时，方法体包含“return;”语句，如果“return;”语句是最后一行则可以省略。通常return语句通常用在一个方法体的最后，否则会产生编译错误，除非用在if-else语句</code></pre><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul><li><p>作用</p><ul><li>在Java中为了防止类、接口、枚举和注释等命名冲突引用了包（package）概念，包本质上命名空间（namespace） 。在包中可以定义一组相关的类型（类、接口、枚举和注释），并为它们提供访问保护和命名空间管理。</li></ul></li><li><p>包定义</p><ul><li>Java中使用package语句定义包，package语句应该放在源文件的第一行，在每个源文件中只能有一个包定义语句，并且package语句适用于所有类型（类、接口、枚举和注释）的文件。定义包语法格式如下：packagepkg1[.pkg2[.pkg3…]];</li></ul></li><li><p>包引入</p><ul><li>使用import语句实现引入包，import语句应位于package语句之后，所有类的定义之前，可以有0~n条import语句，其语法格式为：import package1[.package2…].(类型名|*);</li><li>“包名.类型名”形式只引入具体类型，“包名.*”采用通配符，表示引入这个包下所有的类型。</li></ul></li><li><p>常用包</p><ul><li><p>Java SE提供一些常用包，其中包含了Java开发中常用的基础类。这些包有：java.lang、java.io、java.net、java.util、java.text、java.awt和javax.swing。</p></li><li><ol><li>java.lang包</li></ol><ul><li>java.lang包含中包含了Java语言的核心类，如Object、Class、String、包装类和Math等，还有包装类Boolean、Character、Integer、Long、Float和Double。使用java.lang包中的类型，不需要显示使用import语句引入，它是由解释器自动引入。</li></ul></li><li><ol start="2"><li>java.io包</li></ol><ul><li>java.io包含中提供多种输入/输出流类，如InputStream、OutputStream、Reader和Writer。还有文件管理相关类和接口，如File和FileDescriptor类以及FileFilter接口。</li></ul></li><li><ol start="3"><li>java.net包</li></ol><ul><li>java.net包含进行网络相关的操作的类，如URL、Socket和ServerSocket等。</li></ul></li><li><ol start="4"><li>java.util包</li></ol><ul><li>java.util包含一些实用工具类和接口，如集合、日期和日历相关类和接口。</li></ul></li><li><ol start="5"><li>java.text包</li></ol><ul><li>java.text包中提供文本处理、日期式化和数字格式化等相关类和接口。</li></ul></li><li><ol start="6"><li>java.awt和javax.swing包</li></ol><ul><li>java.awt和javax.swing包提供了Java图形用户界面开发所需要的各种类和接口。java.awt提供是一些基础类和接口，javax.swing提供了一些高级组件。</li></ul></li></ul></li></ul><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><ul><li>在设计一个类时将具有相似功能的方法起相同的名字。方法重载中参数列表不同的含义是：参数的个数不同或者是参数类型不同</li><li>这些相同名字的方法之所以能够在一个类中同时存在，是因为它们的方法参数列表，调用时根据参数列表调用相应重载方法</li></ul><h3 id="封装性与访问控制"><a href="#封装性与访问控制" class="headerlink" title="封装性与访问控制"></a>封装性与访问控制</h3><ul><li><p>访问控制修饰符 : default, public , protected, private</p><ul><li>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</li><li>default (默认级别）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>private （私有级别）: 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。</li><li>public（公有级别） : 对所有类可见。使用对象：类、接口、变量、方法</li><li>protected （保护级别）: 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）基类的 protected 成员是包内可见的，并且对子类可见；若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。</li></ul></li><li><p>非访问控制修饰符 : final, abstract, static, synchronized</p><ul><li><p>static 修饰符，用来修饰类方法和类变量。</p><ul><li>静态变量：static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</li><li>静态方法：static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</li><li>对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。</li></ul></li><li><p>final 修饰符，用来修饰类、方法和变量</p><ul><li>final 修饰的类不能够被继承，父类中的 final 方法可以被子类继承，但是不能被子类重写。修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li></ul></li><li><p>abstract 修饰符，用来创建抽象类和抽象方法。</p><ul><li>抽象类：抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。抽象类可以包含抽象方法和非抽象方法。</li><li>抽象方法：抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。抽象方法不能被声明成 final 和 static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。抽象方法的声明以分号结尾，例如：public abstract sample();。</li></ul></li><li><p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p><ul><li>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</li><li>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</li><li>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个 volatile 对象引用可能是 null</li></ul></li></ul></li><li><p>访问控制和继承</p><ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li><li>父类中声明为 private 的方法，不能够被子类继承。</li></ul></li><li><p>访问类成员</p><ul><li><p>访问成员有两种方式：一种是调用，即通过类或对象调用它的成员，如p.printX()语句；另<br>一种是继承，即子类继承父类的成员变量和方法</p><ul><li>公有访问级别任何情况下两种方式都可以；</li><li>默认访问级别在同一包中两种访问方式都可以，不能在包之外访问；</li><li>保护访问级别在同一包中与默认访问级别一样，两种访问方式都可以。但是在不同包之外只能继承访问；</li><li>私有访问级别只能在本类中通过调用方法访问，不能继承访问。</li></ul></li><li><p>访问类成员时，在能满足使用的前提下，应尽量限制类中成员的可见性，访问级别顺序是：私有级别→默认级别→保护级别→公有级别。</p></li></ul></li></ul><h3 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h3><ul><li>static修饰的成员变量是静态变量，staitc修饰的方法是静态方法，没有static修饰的成员变量是实例变量，没有staitc修饰的方法是实例方法，</li><li>静态方法可以访问静态变量和其他静态方法，实例方法可以访问实例变量、其他实例方法、静态变量和静态方法</li></ul><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><ul><li>静态变量可以在声明的同时初始化，如果初始化静态变量不是简单常量，需要进行计算才能初始化，可以使用静态（static）代码块，静态代码块在类第一次加载时执行，并只执行一次</li><li>在静态代码块中可以初始化静态变量，也可以调用静态方法。</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul><li><p>类实例化可生成对象，实例方法就是对象方法，实例变量就是对象属性。一个对象的生命周期包括三个阶段：创建、使用和销毁；创建对象包括两个步骤：声明和实例化。</p></li><li><ol><li>声明</li></ol><ul><li>声明对象与声明普通变量没有区别，语法格式如下：type objectName;其中type是引用类型，即类、接口和数组</li></ul></li><li><ol start="2"><li>实例化</li></ol><ul><li>实例化过程分为两个阶段：为对象分配内存空间和初始化对象，首先使用new运算符为对象分配<br>内存空间，然后再调用构造方法初始化对象。示例代码如下：String name;<br>name = new String(“Hello World”);</li></ul></li></ul><h3 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h3><ul><li>一个引用变量没有通过new分配内存空间，这个对象就是空对象，Java使用关键字null表示空对象，引用变量默认值是null。当试图调用一个空对象的实例变量或实例方法时，会抛出空指针异常NullPointerException</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>构造方法是类中特殊方法，用来初始化类的实例变量，这个就是构造方法，它在创建对象（new运算符）之后自动调用。</li><li><ol><li>构造方法名必须与类名相同。</li></ol></li><li><ol start="2"><li>构造方法没有任何返回值，包括void。</li></ol></li><li><ol start="3"><li>构造方法只能与new运算符结合使用。</li></ol></li></ul><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><ul><li><p>this指向对象本身，一个类可以通过this来获得一个代表它自身的对象变量。this使用在如下三种情况中：</p></li><li><p>调用实例变量。</p><ul><li>参数是作用域为整个方法的局部变量，为了防止局部变量与成员变量命名发生冲突，可以使用this调用成员变量</li></ul></li><li><p>调用实例方法。</p><ul><li>this也可以调用本对象的方法</li></ul></li><li><p>调用其他构造方法</p><ul><li>使用this调用其他构造方法时，this语句一定是该构造方法的第一条语句</li></ul></li></ul><h3 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h3><ul><li>对象不再使用时应该销毁，Java语言对象是由垃圾回收器（Garbage Collection）收集然后释放</li><li>垃圾回收器（Garbage Collection）的工作原理是：当一个对象的引用不存在时，认为该对象不再需要，垃圾回收器自动扫描对象的动态内存区，把没有引用的对象作为垃圾收集起来并释放。</li></ul><h2 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h2><h3 id="Java中的继承"><a href="#Java中的继承" class="headerlink" title="Java中的继承"></a>Java中的继承</h3><ul><li>继承使用的关键字是extends，extends后面的是父类，如果在类的声明中没有使用extends关键字指明其父类，则默认父类为Object类，java.lang.Object类是Java的根类，所有Java类包括数组都直接或间接继承了Object类，Object类中定义了一些有关面向对象机制的基本方法，如equals()、toString()和finalize()等方法。</li><li>在Java中，类的继承只能是单继承，而多重继承可以通过实现多个接口实现</li></ul><h3 id="调用父类构造方法"><a href="#调用父类构造方法" class="headerlink" title="调用父类构造方法"></a>调用父类构造方法</h3><ul><li><p>当子类实例化时，不仅需要初始化子类成员变量，也需要初始化父类成员变量，初始化父类成员变量需要调用父类构造方法，子类使用super关键字调用父类构造方法</p></li><li><p>super语句必须位于子类构造方法的第一行</p></li><li><p>如果构造方法没有super语句，编译器会试图调用父类默认构造方法（无参数构造方法），如果父类Person也没有默认构造方法，那么会发生编译错误。解决这个编译错误有三种办法：</p><ul><li><ol><li>在父类Person中添加默认构造方法，子类Student会隐式调用父类的默认构造方法。</li></ol></li><li><ol start="2"><li>在子类Studen构造方法添加super语句，显式调用父类构造方法，super语句必须是第一条语句。</li></ol></li><li><ol start="3"><li>在子类Studen构造方法添加this语句，显式调用当前对象其他构造方法，this语句必须是第一条语句。</li></ol></li></ul></li></ul><h3 id="成员变量隐藏和方法覆盖"><a href="#成员变量隐藏和方法覆盖" class="headerlink" title="成员变量隐藏和方法覆盖"></a>成员变量隐藏和方法覆盖</h3><ul><li><p>成员变量隐藏</p><ul><li>子类成员变量与父类一样，会屏蔽父类中的成员变量，称为“成员变量隐藏”；如果要调用父类中的x成员变量，则需要super关键字，</li></ul></li><li><p>方法的覆盖（Override）</p><ul><li><p>如果子类方法完全与父类方法相同，即：相同的方法名、相同的参数列表和相同的返回值，只是方法体不同，这称为子类覆盖（Override）父类方法。表示子类重写了父类的方法</p></li><li><p>在声明方法时添加@Override注解@Override注解不是方法覆盖必须的，它只是锦上添花，但添加@Override注解有两个好处：</p><ul><li><ol><li>提高程序的可读性。</li></ol></li><li><ol start="2"><li>编译器检查@Override注解的方法在父类中是否存在，如果不存在则报错</li></ol></li></ul></li><li><p>方法覆盖时应遵循的原则：</p><ul><li><ol><li>覆盖后的方法不能比原方法有更严格的访问控制（可以相同）。</li></ol></li><li><ol start="2"><li>覆盖后的方法不能比原方法产生更多的异常。</li></ol></li></ul></li></ul></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li><p>多态概念</p><ul><li>发生多态要有三个前提条件：</li></ul></li></ul><ol><li>继承。多态发生一定要子类和父类之间。</li><li>覆盖。子类覆盖了父类的方法。</li><li>声明的变量类型是父类类型，但实例则指向子类实例。<ul><li>多态发生时，Java虚拟机运行时根据引用变量指向的实例调用它的方法，而不是根<br>据引用变量的类型调用。</li></ul></li></ol><ul><li><p>引用类型检查</p><ul><li>有时候需要在运行时判断一个对象是否属于某个引用类型，这时可以使用instanceof运算符，instanceof运算符语法格式如下：<br>obj instanceof type      其中obj是一个对象，type是引用类型，如果obj对象是type引用类型实例则返回true，否则false。</li></ul></li><li><p>引用类型转换</p><ul><li>引用类型可以进行转换，但并不是所有的引用类型都能互相转换，只有属于同一棵继承层次树中的引用类型才可以转换</li><li>引用类型转换也是通过小括号运算符实现，类型转换有两个方向：将父类引用类型变量转换为子类类型，这种转换称为向下转（downcast）；将子类引用类型变量转换为父类类型，这种转换称为向上转型（upcast）。向下转型需要强制转换，而向上转型是自动的。</li></ul></li><li><p>final关键字</p><ul><li><p>final修饰变量</p><ul><li><p>final修饰的变量即成为常量，无论是哪种常量都只能赋值一次，但是final所修饰局部变量和成员变量有所不同。</p></li><li><ol><li>final修饰的局部变量必须使用之前被赋值一次才能使用。</li></ol></li><li><ol start="2"><li>final修饰的成员变量在声明时没有赋值的叫“空白final变量”。空白final变量必须在构造方法或静态代码块中初始化。</li></ol><ul><li>其实局部常量最好在声明的同时初始化</li><li>如果是空白final变量是实例常量，则需要在构造方法中初始化</li><li>如果是空白final变量是静态常量，则需要在静态代码块中初始化</li></ul></li></ul></li><li><p>final修饰类</p><ul><li>final修饰的类不能被继承。有时出于设计安全的目的，不想让自己编写的类被别人继承，这时可以使用final关键字修饰父类。</li></ul></li><li><p>final修饰方法</p><ul><li>final修饰的方法不能被子类覆盖。有时也是出于设计安全的目的，父类中的方法不想被别人覆盖，这是可以使用final关键字修饰父类中方法。</li></ul></li></ul></li></ul><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li><p>抽象类概念</p><ul><li>在Java中具有抽象方法的类称为“抽象类”</li><li>Java语言提供了两种类：一种是具体类；另一种是抽象子类</li><li>抽象类不能被实例化,只有具体类才能被实例化</li></ul></li><li><p>抽象类声明和是实现</p><ul><li>在Java中抽象类和抽象方法的修饰符是abstract</li><li>抽象方法中只有方法的声明，没有方法的实现，即没有大括号（{}）部分</li><li>如果一个方法被声明为抽象的，那么这个类也必须声明为抽象的。而一个抽象类中，可以有0<del>n个抽象方法，以及0</del>n具体方法</li><li>设计抽象方法目的就是让子类来实现的，否则抽象方法就没有任何意义</li></ul></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>接口概念</p><ul><li>接口中所有方法都是抽象的，而且接口可以<br>有成员变量，在接口中成员变量都静态成员变量，即省略了public static final修饰符</li><li>接口与抽象类一样都不能被实例化</li></ul></li><li><p>接口声明和实现</p><ul><li>声明：在Java中接口的声明使用的关键字是interface</li><li>实现：某个类实现接口时，要在声明时使用implements关键字，当实现多个接口之间用逗号（,）分隔。实现接口时要实现接口中声明的所有方法。</li></ul></li><li><p>接口与多继承</p><ul><li>在C++语言中一个类可以继承多个父类，但这会有潜在的风险，如果两个父类有相同的方法，那么子类将继承哪一个父类方法呢？这就是C++多继承所导致的冲突问题。</li><li>在Java中只允许继承一个类，但可实现多个接口。通过实现多个接口方式满足多继承的设计需求。如果多个接口中即便有相同方法，它们也都是抽象的，子类实现它们不会有冲突。</li></ul></li><li><p>接口继承</p><ul><li>Java语言中允许接口和接口之间继承。由于接口中的方法都是抽象方法，所以继承之后也不需要做什么，因此接口之间的继承要比类之间的继承简单的多。</li><li>事实上在接口中覆盖方法，并没有实际意义，因为它们都是抽象的，都是留给子类实现的。</li></ul></li><li><p>Java 8新特性默认方法和静态方法</p><ul><li><p>在Java 8之前Java语言中接口存在如下不足之处：</p><ul><li><ol><li>不能可选实现方法，接口的方法全部是抽象的，实现接口时必须全部实现接口中方法，哪怕是有些方法并不需要，也必须实现。</li></ol></li><li><ol start="2"><li>没有静态方法。</li></ol></li></ul></li><li><p>针对这些问题，Java 8在接口中提供了声明默认方法和静态方法的能力</p></li><li><p>接口中的默认方法类似于类中具体方法，给出了具体实现，只是方法修饰符是default。接口中静态方法类似于类中静态方法。</p></li><li><p>实现接口时接口中原有的抽象方法在实现类中必须实现。默认方法可以根据需要有选择实现（覆<br>盖）。静态方法不需要实现，实现类中不能拥有接口中的静态方法。</p></li><li><p>接口中声明的静态方法与其他实现类没<br>有任何关系，只能通过接口名调用</p></li></ul></li><li><p>抽象类与接口的区别</p><ul><li><ol><li>接口支持多继承，而抽象类（包括具体类）只能继承一个父类。</li></ol></li><li><ol start="2"><li>接口中不能有实例成员变量，接口所声明的成员变量全部是静态常量，即便是变量不加public static final修饰符也是静态常量。抽象类与普通类一样各种形式的成员变量都可以声明。</li></ol></li><li><ol start="3"><li>接口中没有包含构造方法，由于没有实例成员变量，也就不需要构造方法了。抽象类中可以有实例成员变量，也需要构造方法。</li></ol></li><li><ol start="4"><li>抽象类中可以声明抽象方法和具体方法。Java 8之前接口中只有抽象方法，而Java 8之后接口中也可以声明具体方法，具体方法通过声明默认方法实现。</li></ol></li></ul></li></ul><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><h3 id="枚举概念"><a href="#枚举概念" class="headerlink" title="枚举概念"></a>枚举概念</h3><ul><li><p>Java 5之后提供了枚举类型，Java枚举类型本质上是一种继承java.lang.Enum类，是引用数据类型，因此也称为“枚举类”。</p></li><li><p>Java中枚举类型的作用已经不仅仅是定义一组常量提高程序的可读性了，还具有如下特性：</p><ul><li><ol><li>Java枚举类型是一种类，是引用类型，具有了面向对象特性，可以添加方法和成员变量等。</li></ol></li><li><ol start="2"><li>Java枚举类型父类是java.lang.Enum，不需要显式声明。</li></ol></li><li><ol start="3"><li>Java枚举类型可以实现接口，与类实现接口类似。</li></ol></li><li><ol start="4"><li>Java枚举类型不能被继承，不存在子类。</li></ol></li></ul></li></ul><h3 id="枚举声明"><a href="#枚举声明" class="headerlink" title="枚举声明"></a>枚举声明</h3><ul><li><p>Java中是使用enum关键词声明枚举类，具体定义放在一对大括号内，枚举的语法格式如下：<br>[public] enum 枚举名 {<br>枚举常量列表<br>}    “枚举常量列表”是枚<br>举的核心，它由一组相关常量组成。</p></li><li><p>使用枚举类时，赋值过程中实例化枚举类对象，赋值表达式是“枚举类型名.枚举常量”的形式，并初始化为枚举常量</p></li><li><p>枚举类与switch语句能够很好地配合使用，case常量直接使用枚举常量，而且不需要枚举类名作为前缀，使用起来比较简洁</p></li><li><p>在switch中使用枚举类型时，switch语句中case分支语句个数应该对应枚举常量个数，不要多也不要少，当使用default时，default应该只表示等于最后一个枚举常量情况。</p></li><li><p>枚举类可以像类一样包含成员变量和成员方法，成员变量可以是实例变量也可以是静态变量，成员方法可以是实例方法，也可以是静态方法，但不能是抽象方法。</p></li><li><p>添加的其他成员的枚举类需要注意，“枚举常量列表”语句必须是枚举类中的第一行代码。而且“枚举常量列表”语句后面要加分号（;）表示语句的结束</p></li><li><p>枚举类构造方法</p><ul><li>在类中成员变量的初始化是通过构造方法实的，而在枚举类中也是通过构造方法初始化成员变量的；注意枚举类的中的构造方法只能是私有访问级别，构造方法可以省略private关键字，但它仍然是私有的构造方法。这也说明了枚举类不允许在外部创建对象。</li></ul></li></ul><h3 id="枚举常用方法"><a href="#枚举常用方法" class="headerlink" title="枚举常用方法"></a>枚举常用方法</h3><ul><li><p>所有枚举类都继承java.lang.Enum类，Enum中定义了一些枚举中常用的方法：</p><ul><li>int ordinal()：返回枚举常量的顺序。这个顺序根据枚举常量声明的顺序而定，顺序从零开始。</li><li>枚举类型[] values()：静态方法，返回一个包含全部枚举常量的数组。</li><li>枚举类型 valueOf(String str)：静态方法，str是枚举常量对应的字符串，返回一个包含枚举类型实例。</li></ul></li><li><p>在Java类引用类型进行比较时，有两种比较方法==和equals，==比较的是两个引用是否指向同一个对象，equals是比较对象内容是否相同。但是，枚举引用类型中==和equals都是一样的，<br>都是比较两个引用是否指向同一个实例，枚举类中每个枚举常量无论何时都只有一个实例。</p></li></ul><h2 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h2><h3 id="Java根类-Object"><a href="#Java根类-Object" class="headerlink" title="Java根类-Object"></a>Java根类-Object</h3><ul><li><p>Object类属于java.lang包中的类型，不需要显示使用import语句引入，它是由解释器自动引入。</p></li><li><p>Object类有很多方法，常用的几个方法：</p><ul><li>String toString()：返回该对象的字符串表示。</li><li>boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。</li></ul></li><li><p>toString()方法</p><ul><li>为了日志输出等处理方便，所有的对象都可以以文本方式表示，需要在该对象所在类中覆盖toString()方法。如果没有覆盖toString()方法，默认的字符串是“类名@对象的十六进制哈希码 ”。</li><li>使用System.out.println等输出语句可以自动调用对象的toString()方法将对象转换为字符串输出</li></ul></li><li><p>对象比较方法</p><ul><li><p>==运算符</p><ul><li>==运算符是比较两个引用变量是否指向同一个实例</li></ul></li><li><p>equals()方法</p><ul><li>equals()方法是比较两个对象的内容是否相等，通常字符串的比较，只是关心的内容是否相等。</li><li>equals()方法是继承自Object的，所有对象都可以通过equals()方法比较，问题的关键是需要指定相等的规则，就是要指定比较的是哪些属性相等，所以为了比较两个对象相等，则需要覆盖equals()方法，在该方法中指定比较规则。</li></ul></li></ul></li></ul><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><ul><li><p>范围</p><ul><li>在Java中8种基本数据类型不属于类，不具备“对象”的特征，没有成员变量和方法，不方便进行面向对象的操作。为此，Java提供包装类（Wrapper Class）来将基本数据类型包装成类，每个Java基本数据类型在java.lang包中都有一个相应的包装类，每个包装类对象封装一个基本数据类型数值。除int和char类型外，其他的类型对应规则就是第一个字母大写</li><li>包装类都是final的，不能被继承。包装类都是不可变类，类似于String类，一旦创建了对象，其内容就不可以修改</li></ul></li><li><p>类别</p><ul><li><p>数值包装类(Byte、Short、Integer、Long、Float和Double)</p><ul><li><p>相同点</p><ul><li><ol><li>构造方法类似–每一个数值包装类都有两个构造方法，以Integer为例，Integer构造方法如下：</li></ol><ul><li>Integer(int value)：通过指定一个数值构造Integer对象。</li><li>Integer(String s)：通过指定一个字符串s构造对象，s是十进制字符串表示的数值。</li></ul></li><li><ol start="2"><li>共同的父类–这6个数值包装类有一个共同的父类——Number，Number是一个抽象类，除了这6个子类还有：AtomicInteger、AtomicLong、BigDecimal和BigInteger，Number是抽象类，要求它的子类必须实现如下6个方法</li></ol><ul><li>byte byteValue()：将当前包装的对象转换为byte类型的数值。</li><li>double doubleValue()：将当前包装的对象转换为double类型的数值。</li><li>float floatValue()：将当前包装的对象转换为float类型的数值。</li><li>int intValue()：将当前包装的对象转换为int类型的数值。</li><li>long longValue()：将当前包装的对象转换为long类型的数值。</li><li>short shortValue()：将当前包装的对象转换为short类型的数值。</li></ul></li><li><ol start="3"><li>compareTo()方法</li></ol><ul><li>每一个数值包装类都有int compareTo(数值包装类对象)方法，可以进行包装对象的比较。方法返<br>回值是int，如果返回值是0，则相等；如果返回值小于0，则此对象小于参数对象；如果返回值<br>大于0，则此对象大于参数对象。</li></ul></li><li><ol start="4"><li>字符串转换为基本数据类型–每一个数值包装类都提供一些静态parseXXX()方法将字符串转换为对应的基本数据类型，以<br>Integer为例，方法定义如下：</li></ol><ul><li>static int parseInt(String s)：将字符串s转换有符号的十进制整数。</li><li>static int parseInt(String s, int radix)：将字符串s转换有符号的整数，radix是指定基数，基数用来指定进制。注意这种指定基数的方法在浮点数包装类（Double和Float）中没有的。</li></ul></li><li><ol start="5"><li>基本数据类型转换为字符串–每一个数值包装类都提供一些静态toString()方法实现将基本数据类型数值转换为字符串，以<br>Integer为例，方法定义如下：</li></ol><ul><li>static String toString(int i)：将该整数i转换为有符号的十进制表示的字符串。</li><li>static String toString(int i, int radix)：将该整数i转换为有符号的特定进制表示的字符串，radix是基数可以指定进制。注意这种指定基数的方法在浮点数包装类（Double和Float）中没有的。</li></ul></li></ul></li></ul></li><li><p>Character</p><ul><li><p>Character类是char类型的包装类。Character类常用方法如下：</p><ul><li>Character(char value)：构造方法，通过char值创建一个新的Character对象。</li><li>char charValue()：返回此Character对象的值。</li><li>int compareTo(Character anotherCharacter)：方法返回值是int，如果返回值是0，则相等；如果返<br>回值小于0，则此对象小于参数对象；如果返回值大于0，则此对象大于参数对象。</li></ul></li></ul></li><li><p>Boolean</p><ul><li><p>01.构造方法Boolean类是boolean类型的包装类。Boolean类有两个构造方法，构造方法定义如下：</p><ul><li>Boolean(boolean value)：通过一个boolean值创建Boolean对象。</li><li>Boolean(String s)：通过字符串创建Boolean对象。s不能为null，s如果是忽略大小<br>写”true”则转换为true对象，其他字符串都转换为false对象。</li></ul></li><li><ol start="2"><li>compareTo()方法</li></ol><ul><li>Boolean类有int compareTo(Boolean包装类对象)方法，可以进行包装对象的比较。方法返回值是int，如果返回值是0，则相等；如果返回值小于0，则此对象小于参数对象；如果返回值大于0，则此对象大于参数对象。</li></ul></li><li><ol start="3"><li>字符串转换为boolean类型</li></ol><ul><li>Boolean包装类都提供静态parseBoolean()方法实现将字符串转换为对应的boolean类型，方法定义如下：</li><li>static boolean parseBoolean(String s)：将字符串转换为对应的boolean类。s不能为null，s如果是忽略大小写”true”则转换为true，其他字符串都转换为false。</li></ul></li></ul></li></ul></li><li><p>自动装箱/拆箱</p><ul><li>拆箱(unboxing )：拆箱能够将包装类对象自动转换为基本数据类型的数值，而不需要使用intValue()或doubleValue()等方法</li><li>自动装箱( autoboxing )：装箱能够自动地将基<br>本数据类型的数值自动转换为包装类对象，而不需要使用构造方法。</li><li>在自动装箱和拆箱时，要避免空对象，拆箱的过程本质上是调用intValue()方法实现的，试图访问空对象的方法和成员变量，就会抛出运行期NullPointerException异常。</li></ul></li></ul><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><ul><li><ol><li>舍入方法</li></ol><ul><li>static double ceil(double a)：返回大于或等于a最小整数。</li><li>static double floor(double a)：返回小于或等于a最大整数。</li><li>static int round(float a)：四舍五入方法。</li></ul></li><li><ol start="2"><li>最大值和最小值</li></ol><ul><li>static int min(int a, int b)：取两个int整数中较小的一个整数。</li><li>static int min(long a, long b)：取两个long整数中较小的一个整数。</li><li>static int min(float a, float b)：取两个float浮点数中较小的一个浮点数。</li><li>static int min(double a, double b)：取两个double浮点数中较小的一个浮点数。</li><li>max方法取两个数中较大的一个数，max方法与min方法参数类似也有4个版本</li></ul></li><li><ol start="3"><li>绝对值</li></ol><ul><li>static int abs(int a)：取int整数a的绝对值。</li><li>static long abs(long a)：取long整数a的绝对值。</li><li>static float abs(float a)：取float浮点数a的绝对值。</li><li>static double abs(double a)：取double浮点数a的绝对值。</li></ul></li><li><ol start="4"><li>三角函数</li></ol><ul><li>static double sin(double a)：返回角的三角正弦。</li><li>static double cos(double a)：返回角的三角余弦。</li><li>static double tan(double a)：返回角的三角正切。</li><li>static double asin(double a)：返回一个值的反正弦。</li><li>static double acos(double a)：返回一个值的反余弦。</li><li>static double atan(double a)：返回一个值的反正切。</li><li>static double toDegrees(double angrad)：将弧度转换为角度。</li><li>static double toRadians(double angdeg)：将角度转换为弧度。</li></ul></li><li><ol start="5"><li>对数运算</li></ol><ul><li>static double log(double a)，返回a的自然对数。</li></ul></li><li><ol start="6"><li>平方根</li></ol><ul><li>static double sqrt(double a)，返回a的正平方根。</li></ul></li><li><ol start="7"><li>幂运算</li></ol><ul><li>static double pow(double a, double b)，返回第一个参数的第二个参数次幂的值。</li></ul></li><li><ol start="8"><li>计算随机值</li></ol><ul><li>static double random()，返回大于等于 0.0 且小于 1.0随机数。</li></ul></li><li><ol start="9"><li>常量</li></ol><ul><li>圆周率PI</li><li>自然对数的底数E。</li></ul></li></ul><h3 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h3><ul><li><p>BigInteger</p><ul><li><p>java.math.BigInteger是不可变的任意精度的大整数。BigInteger构造方法有很多，其中字符串参数的构造方法有两个：</p><ul><li>BigInteger(String val)：将十进制字符串val转换为BigInteger对象。</li><li>BigInteger(String val, int radix)：按照指定基数radix将字符串val转换为BigInteger对象。</li></ul></li><li><p>BigInteger提供多种方法，常用方法如下：</p><ul><li>int compareTo(BigInteger val)：将当前对象与参数val进行比较，方法返回值是int，如果返回值是0，则相等；如果返回值小于0，则此对象小于参数对象；如果返回值大于0，则此对象大于参数对象。</li><li>BigInteger add(BigInteger val)：加运算，当前对象数值加参数val。</li><li>BigInteger subtract(BigInteger val)：减运算，当前对象数值减参数val。</li><li>BigInteger multiply(BigInteger val)：乘运算，当前对象数值乘参数val。</li><li>BigInteger divide(BigInteger val)：除运算，当前对象数值除以参数val。</li><li>BigInteger继承了抽象类Number，那么它还有实现抽象类Number的6个方法</li></ul></li></ul></li><li><p>BigDecimal</p><ul><li><p>java.math.BigDecimal是不可变的任意精度的有符号十进制数，BigDecimal构造方法有很多：</p><ul><li>BigDecimal(BigInteger val)：将BigInteger对象val转换为BigDecimal对象。</li><li>BigDecimal(double val)：将double转换为BigDecimal对象，参数val是double类型的二进制浮点值准确的十进制表示形式。</li><li>BigDecimal(int val)：将int转换为BigDecimal对象。</li><li>BigDecimal(long val)：将long转换为BigDecimal对象。</li><li>BigDecimal(String val)：将字符串表示数值形式转换为BigDecimal对象。</li></ul></li><li><p>BigDecimal提供多种方法，常用的方法如下：</p><ul><li>int compareTo(BigDecimal val)：将当前对象与参数val进行比较，方法返回值是int，如果返回值是0，则相等；如果返回值小于0，则此对象小于参数对象；如果返回值大于0，则此对象大于参数对象。</li><li>BigDecimal add(BigDecimal val)：加运算，当前对象数值加参数val。</li><li>BigDecimal subtract(BigDecimal val)：减运算，当前对象数值减参数val。</li><li>BigDecimal multiply(BigDecimal val)：乘运算，当前对象数值乘参数val。</li><li>BigDecimal divide(BigDecimal val)：除运算，当前对象数值除以参数val。</li><li>BigDecimal divide(BigDecimal val, int roundingMode)：除运算，当前对象数值除以参数val。roundingMode要应用的舍入模式。</li><li>BigDecimal继承了抽象类Number，那么它还实现抽象类Number的6个方法</li></ul></li></ul></li></ul><h3 id="日期时间相关类"><a href="#日期时间相关类" class="headerlink" title="日期时间相关类"></a>日期时间相关类</h3><ul><li><p>Java8之前日期相关类</p><ul><li><p>Date类</p><ul><li><p>在Java SE核心类中有两个Date，分别是java.util.Date和java.sql.Date。java.util.Date就是日期时间类，而java.sql.Date是JDBC中日期字段类型。</p></li><li><p>Java 8之前与日期时间相关类还有DateFormat、Calendar和TimeZone，DateFormat用于日期格式化，Calendar日历类，TimeZone是时区类。</p></li><li><p>构造方法</p><ul><li>Date()：用当前时间创建Date对象，精确到毫秒。</li><li>Date(long date)：指定标准基准时间以来的毫秒数创建Date对象。标准基准时间是格林威治时间<br>1970年1月1日00:00:00。</li></ul></li><li><p>普通方法</p><ul><li>boolean after(Date when)：测试此日期是否在when日期之后。</li><li>boolean before(Date when)：测试此日期是否在when日期之前。</li><li>int compareTo(Date anotherDate)：比较两个日期的顺序。如果参数日期等于此日期，则返回值0；如果此日期在参数日期之前，则返回小于0的值；如果此日期在参数日期之后，则返回大于0的值。</li><li>long getTime()：返回自1970年1月1日00:00:00以来此Date对象表示的毫秒数。</li><li>void setTime(long time)：用毫秒数time设置日期对象，time是自1970年1月1日00:00:00以来此Date对象表示的毫秒数。</li></ul></li><li><p>日期格式化和解析</p><ul><li><p>日期格式化类是java.text.DateFormat，DateFormat是抽象类，它的常用具体类<br>是java.text.SimpleDateFormat。</p></li><li><p>DateFormat中提供日期格式化和日期解析方法，具体方法说明如下：</p><ul><li>String format(Date date)：将一个Date格式化为日期/时间字符串。</li><li>Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期对象。如果解析失败则抛出ParseException。</li></ul></li><li><p>具体类是SimpleDateFormat构造方法如下：</p><ul><li>SimpleDateFormat()：用默认的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li><li>SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造<br>SimpleDateFormat。pattern参数是日期和时间格式模式</li></ul></li></ul></li></ul></li><li><p>Calendar类</p><ul><li><p>对日期时间进行操作，可以使用java.util.Calendar类，Calendar是一个抽象类，不能实例化，但是通过静态工厂方法getInstance()获得Calendar实例</p></li><li><p>主要方法</p><ul><li>static Calendar getInstance()：使用默认时区和语言环境获得一个日历。</li><li>void set(int field, int value)：将给定的日历字段设置为给定值。</li><li>void set(int year,int month,int date)：设置日历字段YEAR、MONTH和DAY_OF_MONTH的值</li><li>Date getTime()：返回一个表示此Calendar时间值（从1970年1月1日00:00:00至现在的毫秒数）的Date对象。</li><li>boolean after(Object when)：判断此Calendar表示的时间是否在指定时间之后，返回判断结果。</li><li>boolean before(Object when)：判断此Calendar表示的时间是否在指定时间之前，返回判断结果。</li><li>int compareTo(Calendar anotherCalendar)：比较两个Calendar对象表示的时间值。</li></ul></li></ul></li></ul></li><li><p>Java8新日期时间相关类</p><ul><li><p>时间和日期</p><ul><li><p>Java 8之后提供了新的日期时间类有三个：LocalDate、LocalTime和LocalDateTime，它们都位于java.time包中，LocalDate表示一个不可变的日期对象；LocalTime表示一个不可变的时间对象；LocalDateTime表示一个不可变的日期和时间。</p></li><li><p>这三个类有类似的方法，这三个类并没有提供公有的构造方法，创建它们对象可以使用静态工厂方法，主要有now()和of()方法。</p><ul><li><p>now()方法说明如下：</p><ul><li>static LocalDate now()：LocalDate静态工厂方法，该方法使用默认时区获得当前日期，返回<br>LocalDate对象。</li><li>static LocalTime now()：LocalTime静态工厂方法，该方法使用默认时区获得当前时间，返回<br>LocalTime对象。</li><li>static LocalDateTime now()：LocalDateTime静态工厂方法，该方法使用默认时区获得当前日期时间，返回LocalDateTime对象。</li></ul></li><li><p>of()方法有很多重载方法，说明如下：</p><ul><li>static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)：按照指定的年、月、日、小时、分钟和秒获得LocalDateTime实例，将纳秒设置为零。</li><li>static LocalTime of(int hour, int minute, int second)：按照指定的小时、分钟和秒获取一个<br>LocalTime实例。</li><li>static LocalDate of(int year, int month, int dayOfMonth)：按照指定的年、月和日获得一个<br>LocalDate实例，日期中年、月和日必须有效，否则将抛出异常。</li></ul></li></ul></li></ul></li><li><p>日期格式化和解析</p><ul><li><p>日期格式化</p><ul><li>日期格式化方法是format，这三个类每一个都有String format(DateTimeFormatter formatter)，参数formatter是DateTimeFormatter类型。</li></ul></li><li><p>日期解析</p><ul><li><p>日期解析方法是parse，这三个类每一个都有两个版本的parse方法</p><ul><li>static LocalDateTime parse(CharSequence text)：使用默认格式，从一个文本字符串获取一<br>个LocalDateTime实例，如2007-12-03T10:15:30。</li><li>static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter)：使用指定格式化，从文本字符串获取LocalDateTime实例。</li><li>static LocalDate parse(CharSequence text)：使用默认格式，从一个文本字符串获取一个<br>LocalDate实例，如2007-12-03。</li><li>static LocalDate parse(CharSequence text, DateTimeFormatter formatter)：使用指定格式化，从文本字符串获取LocalDate实例。</li><li>static LocalTime parse(CharSequence text)：使用默认格式，从一个文本字符串获取一个<br>LocalTime实例。</li><li>static LocalTime parse(CharSequence text, DateTimeFormatter formatter)：使用指定的格式化，从文本字符串获取LocalTime实例。</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul><li><p>内部类概述</p><ul><li>Java语言中允许在一个类（或方法、代码块）的内部定义另一个类，后者称为“内部类”（Inner<br>Classes），也称为“嵌套类”（Nested Classes），封装它的类称为“外部类”。内部类与外部类之间存在逻辑上的隶属关系，内部类一般只用在封装它的外部类或代码块中使用。</li></ul></li><li><p>内部类的作用</p><ul><li><ol><li>封装。将不想公开的实现细节封装到一个内部类中，内部类可以声明为私有的，只能在所在外部类中访问。</li></ol></li><li><ol start="2"><li>提供命名空间。静态内部类和外部类能够提供有别于包的命名空间。</li></ol></li><li><ol start="3"><li>便于访问外部类成员。内部类能够很方便访问所在外部类的成员，包括私有成员也能访问。</li></ol></li></ul></li><li><p>分类</p><ul><li><p>有名内部类</p><ul><li><p>局部内部类</p></li><li><p>成员内部类</p><ul><li>实例内部类</li><li>静态内部类</li></ul></li></ul></li><li><p>匿名内部类</p></li></ul></li><li><p>成员内部类</p><ul><li><p>成员内部类类似于外部类的成员变量，在外边类的内部，且方法体和代码块之外定义的内部类。</p></li><li><p>实例内部类</p><ul><li>实例内部类与实例变量类似，可以声明为公有级别、私有级别、默认级别或保护级别，即4种访问级别都可以，而外部类只能声明为公有或默认级别。</li><li>在内部类中this是引用当前内部类对象，而要引用外部类对象需要使用“外部类名.this”，如果内部类和外部类它们的成员命名没有冲突情况下，在引用外部类成员时可以不用加“外部类名.this”</li></ul></li><li><p>静态内部类</p><ul><li>静态内部类与静态变量类似，在声明的时候使用关键字static修饰，静态内部类只能访问外部类静态成员，所以静态内部类使用的场景不多。但可以提供有别于包的命名空间。</li><li>在声明静态内部时采用“内部类.静态内部类”形<br>式，实例化也是如此形式。</li></ul></li></ul></li><li><p>局部内部类</p><ul><li>局部内部类就是在方法体或代码块中定义的内部类，局部内部类的作用域仅限于方法体或代码块中。局部内部类访问级别只能是默认的，不能是公有的、私有的和保护的访问级别，即不能使用public、private和protected修饰。局部内部类也不能是静态，即不能使用static修饰。局部内部类可以访问外部类所有成员。</li><li>实例化内部类后马上调用它的方法，没有为内部类对象分配一个引用变量名，这种写法称为“匿名对象”。匿名对象适合只运行一次情况下。</li></ul></li><li><p>匿名内部类</p><ul><li>匿名内部类是没有名字的内部类，本质上是没有名的局部内部类，具有局部内部类所有特征。例如：可以访问外部类所有成员。如果匿名内部类在方法中定义，它所访问的参数需要声明为final的。</li><li>匿名内部类通常用来实现接口或抽象类的，很少覆盖具体类</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令</title>
      <link href="/posts/4.html"/>
      <url>/posts/4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h3 id="上下键"><a href="#上下键" class="headerlink" title="上下键"></a>上下键</h3><ul><li>选择之前执行过的历史命令，history指令可以查看历史指令列表</li></ul><h3 id="Tab键"><a href="#Tab键" class="headerlink" title="Tab键"></a>Tab键</h3><ul><li>自动补全准备输入的命令或文件名，如果按一下没有补全，就按两下，会列出所有可能的结果</li></ul><h3 id="CTRL-c"><a href="#CTRL-c" class="headerlink" title="CTRL+c"></a>CTRL+c</h3><ul><li>结束正在执行的命令。（如果还结束不了，关闭终端窗口）</li></ul><h3 id="clear或者CTRL-L"><a href="#clear或者CTRL-L" class="headerlink" title="clear或者CTRL+L"></a>clear或者CTRL+L</h3><ul><li>清除屏幕中的内容</li></ul><h2 id="终端命令"><a href="#终端命令" class="headerlink" title="终端命令"></a>终端命令</h2><h3 id="终端命令行与ls命令"><a href="#终端命令行与ls命令" class="headerlink" title="终端命令行与ls命令"></a>终端命令行与ls命令</h3><ul><li><p>ifconfig命令</p><ul><li>查看本机的IP地址</li></ul></li><li><p>[root@localhost ~]#</p><ul><li>root：当前登录的用户</li><li>@localhost:当前登录的系统名</li><li>~：当前所在目录 ~代表当前用户的主目录</li><li>#:代表管理员权限</li><li>$:代表普通用户权限</li></ul></li><li><p>ls命令:列出目录中的文件和文件夹</p><ul><li><p>ls -l 等价于 ll</p><ul><li>列出当前目录中的文件列表的详细信息（不显示隐藏文件）</li></ul></li><li><p>ls -a</p><ul><li>列出当前目录中的所有文件，包括隐藏文件(隐藏文件或文件夹名字以 . 开头)</li></ul></li><li><p>ls -A</p><ul><li>显示所有的文件和目录，包括隐藏文件和目录，但是不显示“.”和”..”目录</li></ul></li><li><p>ls -t</p><ul><li>根据时间排序</li></ul></li><li><p>ls /etc</p><ul><li>列出/etc目录下的文件信息</li></ul></li><li><p>ls -al 等价于 ls -a -l</p><ul><li>可以将单字母的选项一起写，两个功能都能实现</li></ul></li></ul></li></ul><h3 id="在线帮助命令"><a href="#在线帮助命令" class="headerlink" title="在线帮助命令"></a>在线帮助命令</h3><ul><li><p>man命令</p><ul><li>例如： man ls</li></ul></li><li><p>help命令</p><ul><li>查看外部命令的帮助文档，格式为“命令 –help”，如：passwd –help</li><li>查看内部命令的帮助文档，格式为“help 命令”，如：help ls</li></ul></li><li><p>type命令</p><ul><li>判断命令到底为内部命令还是外部命令</li><li>内部命令返回如： help is a shell builtin</li><li>外部命令返回如:  passwd is/usr/bin/passwd</li></ul></li><li><p>其他方式</p><ul><li>使用搜索引擎查找</li></ul></li><li><p>whereis命令</p><ul><li>用于查找与某一命令相关的文件的存放位置</li><li>whereis -b ：只查找二进制文件</li><li>whereis -m： 只查找手册页，说明文件</li><li>whereis -s：查找源程序文件</li></ul></li></ul><h3 id="文件和目录操作命令"><a href="#文件和目录操作命令" class="headerlink" title="文件和目录操作命令"></a>文件和目录操作命令</h3><ul><li><p>目录</p><ul><li>根目录：/</li><li>/etc:保存系统数据文件、启动文件和脚本等</li><li>/bin:存放普通用户常用的命令</li><li>/sbin:存放系统管理方面的常用命令</li><li>/boot:存放系统核心文件</li><li>/dev:存放与设备有关的文件</li><li>/lib:存放在编译某些程序时要用的函数库</li><li>/usr:存放用户安装的应用程序，类似于Windows系统中的program files目录</li><li>/var:存放系统数据文件</li><li>/root:系统管理员（root用户）的属主目录</li><li>/home:存放普通用户属主目录的目录</li><li>/media:在系统自动挂载存储设备时（如光驱、U盘）使用的目录</li><li>.  :表示当前目录</li><li>.. :表示当前目录的上一层目录</li><li>~ ：表示当前用户的属主目录</li></ul></li><li><p>vi编辑器</p><ul><li><p>一般模式</p><ul><li>数字0 ：光标移动到本行行首</li><li>$ :光标移动到本行行尾</li><li>G：光标移动到文本的最末行</li><li>gg：光标移动到该文本的首行</li><li>dd：删除光标所在的那一行</li><li>ndd(n为数字)：删除光标所在位置向下的n 行</li><li>x、X：x表示向后删除一个字符，X 表示向前删除一个字符</li></ul></li><li><p>编辑模式</p><ul><li>i:在当前字符前插入字符</li><li>a:在当前字符后插入字符</li><li>o:在当前行下插入新的一行</li><li>O：在当前行上插入新的一行</li><li>r:替换光标所在的字符，只替换一次</li></ul></li><li><p>命令行模式</p><ul><li>:w 将编辑过的文本保存</li><li>:q 退出vim</li><li>:wq 保存文本 ，并退出</li><li>:q!  不管编辑或不编辑文本都不保存并退出</li></ul></li></ul></li><li><p>文件与目录操作命令</p><ul><li><p>cd命令</p><ul><li>cd  相对路径或绝对路径</li><li>cd .. 返回上一级目录</li><li>cd ~ 回到自己的属主目录</li></ul></li><li><p>pwd命令</p><ul><li>用于显示当前所在的目录</li></ul></li><li><p>mkdir命令</p><ul><li>mkdir 目录名称   用于创建目录</li><li>mkdir 目录名称 目录名称 用于创建多个目录</li></ul></li><li><p>rmdir命令</p><ul><li>rmdir 目录名称  用于删除目录，删除文件夹时，文件夹必须是空的</li></ul></li><li><p>cp命令</p><ul><li>用于复制文件，对文件的重命名</li></ul></li><li><p>rm命令</p><ul><li><p>用于删除文件</p><ul><li>rm -f 强制删除，不提示用户是否需要删除的信息</li><li>rm -r 循环删除，常用于删除目录</li></ul></li></ul></li><li><p>mv命令</p><ul><li>用于移动文件或目录，对文件或目录的重命名操作</li></ul></li><li><p>管道命令 （|）将|左边命令的输出结果作为|右边命令的输入数据</p></li></ul></li><li><p>创建目录或文件</p><ul><li><p>mkdir命令</p><ul><li>mkdir 目录名称   用于创建目录</li><li>mkdir 目录名称 目录名称 用于创建多个目录</li></ul></li><li><p>touch命令</p><ul><li>创建一个或多个空文件</li><li>touch  文件路径文件名</li></ul></li><li><p>cat &gt;</p><ul><li>如果原来有内容就覆盖原内容</li></ul></li><li><p>cat &gt;&gt;</p><ul><li>追加内容</li></ul></li><li><p>vi编辑器</p><ul><li>vi  文件名称</li></ul></li></ul></li><li><p>查看文件内容命令</p><ul><li><p>cat命令</p><ul><li>cat -n ：连行号一起显示在屏幕上</li><li>cat -b：连行号一起显示在屏幕上，但空行不算</li><li>cat -v：显示控制符号</li></ul></li><li><p>more命令</p><ul><li>用于在屏幕上显示文件内容</li><li>用于分页显示文件列表</li><li>more +n:从第n行开始显示</li><li>more -n:定义屏幕大小为n行，就是每页显示n行</li><li>退出按Q键</li></ul></li><li><p>less命令</p><ul><li>查看文件内容</li><li>less -N：显示每行行号</li><li>退出按Q键</li></ul></li><li><p>head命令</p><ul><li>查看文件的前几行，默认显示10行   </li><li>head -n :表示指定显示多少行</li></ul></li><li><p>tail命令</p><ul><li>显示文件的后几行，默认显示10行  </li><li>tail -n :表示指定显示多少行</li></ul></li></ul></li><li><p>文件与目录权限</p><ul><li><p>chown命令</p><ul><li>用于变更文件及目录的所有者和所属组</li><li>chown -R :表示连同目录下所有文件及子目录都进行变更</li></ul></li><li><p>chmod命令</p><ul><li>修改文件或目录的读写执行权限</li><li>chmod -R :表示连同目录下所有文件及子目录都进行变更</li></ul></li></ul></li><li><p>搜索文件或目录</p><ul><li><p>grep命令</p><ul><li>只显示文件中符合指定条件的行</li><li>grep  需要查找的内容 查找的文件名</li><li>grep -i 需要查找的内容 查找的文件名  查找内容的行，忽略大小写 </li><li>grep -n 需要查找的内容 查找的文件名  查找并显示行号</li></ul></li><li><p>which命令</p><ul><li>用于查找可执行文件的位置</li><li>在当前用户的环境变量PATH路径中寻找指令文件</li></ul></li><li><p>whereis命令</p><ul><li>用于根据设定好的目录查找文件</li><li>查找指令文件，帮助文档及源代码等内容</li></ul></li><li><p>find命令</p><ul><li>用于对指定目录及其所有子目录进行文件搜索</li><li>用find命令查找数据比较消耗硬盘空间（find命令直接查找硬盘数据）</li></ul></li><li><p>locate命令</p><ul><li>查找文件，根据文件列表的数据库查找，速度快，但更新不及时，  updatedb 更新文件列表数据库</li></ul></li></ul></li><li><p>文件打包与压缩</p><ul><li><p>gzip命令</p><ul><li>gzip 文件名   压缩文件为  文件名.gz</li><li>gzip -d  文件名.gz  解压文件</li></ul></li><li><p>zip命令</p><ul><li>zip 文件名.zip  文件名 文件名 可以压缩一个或多个文件</li><li>unzip 文件名.zip 解压缩</li><li>unzip 文件名.zip -d 目录路径   解压到指定目录</li></ul></li><li><p>tar命令</p><ul><li>文件打包与解包</li><li>tar -cvf 文件名.tar  文件名   打包不压缩</li><li>tar -zcvf 文件名.tar.gz  文件名  打包压缩</li><li>tar -xvf 文件名.tar  解包到当前文件夹</li><li>tar -zxvf 文件名.tar.gz  解压到当前文件夹</li><li>tar -zxvf 文件名.tar.gz -C  目录路径  解压到指定目录</li></ul></li></ul></li></ul><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ul><li><p>链接文件  </p><ul><li>ln -选项 源文件 链接文件</li><li>ln命令：新建链接文件</li><li>ln -d  创建硬链接，默认为该参数</li><li>ln -s  创建符号链接</li><li>ln -f 在创建链接时，如果目标文件已经存在，则对其进行替换</li><li>ls -il:查看索引节点号</li></ul></li><li><p>硬盘光盘</p><ul><li><p>df命令</p><ul><li>df -hT 查看硬盘使用情况</li></ul></li><li><p>du命令</p><ul><li>du -sh /home  只查看home目录容量使用情况</li></ul></li><li><p>mount命令</p><ul><li>mount /dev/sr0 /media  将光盘挂载到 /media 文件夹</li><li>umount /dev/sr0  取消挂载</li></ul></li></ul></li></ul><h2 id="Linux系统的管理"><a href="#Linux系统的管理" class="headerlink" title="Linux系统的管理"></a>Linux系统的管理</h2><h3 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h3><ul><li>shutdown -t  数字  指定多少秒后关机</li><li>shutdown -r  时间  指定时间关机后立即重新开机</li><li>shutdown -r now  现在就重启计算机</li><li>shutdown -h  时间   指定时间关机</li><li>shutdown -h now 立即关机</li><li>poweroff 也是立即关机（不能设置关机时间）</li><li>halt  -p  表示挂起系统后关闭系统，相当于 shutdown -h  是最简单的关机命令</li><li>shutdown -c  取消关机进程</li><li>reboot   用于重启计算机 相当于 shutdown -r now</li></ul><h3 id="用户和组管理"><a href="#用户和组管理" class="headerlink" title="用户和组管理"></a>用户和组管理</h3><ul><li><p>groupadd命令</p><ul><li>新建群组</li></ul></li><li><p>groupdel命令</p><ul><li>删除已存在的群组</li></ul></li><li><p>useradd命令</p><ul><li>新建用户  useradd  用户名</li></ul></li><li><p>userdel命令</p><ul><li>删除用户   userdel -r 用户名  删除用户及其主目录中的所有文件</li></ul></li><li><p>usermod命令</p><ul><li>修改用户信息</li></ul></li><li><p>passwd命令</p><ul><li>为用户设定密码</li></ul></li><li><p>su命令</p><ul><li>切换用户   su - 用户名  切换为什么用户</li></ul></li><li><p>sudo命令</p><ul><li>以管理员权限执行指令</li></ul></li><li><p>id命令</p><ul><li>用于显示用户的UID、GID及所拥有的群组</li></ul></li><li><p>groups命令</p><ul><li>用于显示用户所属的群组信息</li></ul></li></ul><h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><ul><li><p>查看磁盘空间</p><ul><li><p>df命令</p><ul><li>用于显示磁盘空间的使用情况</li></ul></li><li><p>du命令</p><ul><li>用于显示指定目录下所有文件及子目录所占用的磁盘空间大小</li></ul></li></ul></li><li><p>磁盘分割</p><ul><li><p>fdisk命令</p><ul><li>用于显示或进行分区</li></ul></li></ul></li><li><p>设备挂载</p><ul><li><p>mount命令</p><ul><li>用于挂载存储设备</li></ul></li><li><p>umount命令</p><ul><li>用于卸载已经挂载的设备</li></ul></li></ul></li></ul><h3 id="安装包管理"><a href="#安装包管理" class="headerlink" title="安装包管理"></a>安装包管理</h3><ul><li><p>rpm命令</p><ul><li>rpm -ivh rpm包名：用于Linux系统下的软件套件安装</li><li>rpm -e 套件名：卸载指定套件</li><li>rpm -e –nodeps 套件名：强制卸载，不考虑套件之间的依赖性</li></ul></li><li><p>yum命令</p><ul><li>yum install 包名：安装指定的包</li><li>yum erase 包名：卸载指定的包</li><li>yum remove 包名：删除已安装的包</li></ul></li><li><p>源码包</p><ul><li>使用源码安装</li></ul></li></ul><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ul><li><p>后台工作管理</p><ul><li><p>&amp;命令</p><ul><li>将当前工作放到后台运行</li></ul></li><li><p>Ctrl+Z组合键</p><ul><li>暂停某工作</li></ul></li><li><p>fg命令</p><ul><li>将后台的工作放到前台来执行</li></ul></li><li><p>jobs命令</p><ul><li>用于查询所有后台的任务</li></ul></li></ul></li><li><p>系统状态监控</p><ul><li><p>ps命令</p><ul><li>用于显示当前系统中运行的进程</li><li>ps aux :列出目前所有内存当中的程序</li><li>ps -ef：列出系统中的所有进程</li></ul></li><li><p>w命令</p><ul><li>用于 查看当前系统负载</li></ul></li><li><p>vmstat命令</p><ul><li>用于监控当前系统状态</li></ul></li><li><p>top命令</p><ul><li>用于动态监控进程所占系统资源，每隔3秒更新一次</li></ul></li><li><p>free命令</p><ul><li>用于查看内存使用情况</li></ul></li><li><p>kill命令</p><ul><li>用于停止进程</li></ul></li></ul></li></ul><h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><ul><li><p>ifconfig命令</p><ul><li>用于显示或设置网卡</li></ul></li><li><p>netstat命令</p><ul><li>用于显示网络连接情况</li><li>netstat -Inp:用于显示当前系统启用哪些端口</li><li>netstat -an：用于显示网络连接情况</li></ul></li><li><p>ping命令</p><ul><li>用于测试目标与本机的连接情况</li></ul></li></ul><h3 id="服务脚本和安全设置"><a href="#服务脚本和安全设置" class="headerlink" title="服务脚本和安全设置"></a>服务脚本和安全设置</h3><ul><li><p>service命令</p><ul><li>用于执行/etc/init.d目录下的服务脚本</li><li>service network restart：重启网络服务</li><li>start ：启动服务</li><li>stop：结束服务</li><li>restart ：重启服务</li><li>status ：显示服务状态</li></ul></li><li><p>setenforce命令</p><ul><li>用于设置SELinux的状态</li><li>setenforce 0：用来关闭SELinux</li><li>setenforce 1：用来开启SELinux</li></ul></li><li><p>getenforce命令</p><ul><li>用于显示当前SELinux的状态</li></ul></li><li><p>防火墙iptables</p><ul><li>service iptables start：开启防火墙</li><li>service iptables stop：关闭防火墙</li></ul></li></ul><h2 id="Web服务器环境的搭建"><a href="#Web服务器环境的搭建" class="headerlink" title="Web服务器环境的搭建"></a>Web服务器环境的搭建</h2><h3 id="安装LAMP"><a href="#安装LAMP" class="headerlink" title="安装LAMP"></a>安装LAMP</h3><ul><li><p>登陆Linux系统</p><ul><li>使用root用户登陆</li></ul></li><li><p>关闭防火墙</p><ul><li>setenforce 0</li></ul></li><li><p>安装Apache</p><ul><li>yum install httpd：安装httpd</li><li>systemctl start httpd.service：启动Apache服务</li></ul></li><li><p>安装MySQL</p></li><li><p>安装PHP</p></li><li><p>重启服务</p></li></ul><h3 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h3><ul><li><p>查看CentOS 是否自带了JDK，如果没有需要先安装JDK</p></li><li><p>复制Tomcat安装包到root用户的属主目录下</p></li><li><p>解压安装包</p></li><li><p>查看Tomcat的默认端口</p><ul><li>8080</li></ul></li><li><p>启动Tomcat</p></li><li><p>获取Linux系统的IP地址，在物理机浏览器中输入“<a href="http://Linux系统的IP地址:8080”来打开">http://Linux系统的IP地址:8080”来打开</a></p></li></ul><h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><h3 id="BASH是centos默认使用的shell"><a href="#BASH是centos默认使用的shell" class="headerlink" title="BASH是centos默认使用的shell"></a>BASH是centos默认使用的shell</h3><ul><li><p>记录历史命令！</p><ul><li>！！：表示执行上一条指令</li><li>！n(n是数字)：表示执行历史命令中第n条指令</li><li>! 字符串：表示执行历史命令中最近一次以“字符串”为开头的指令</li></ul></li><li><p>指令和文件名补全</p><ul><li>tab键</li></ul></li><li><p>别名alias</p></li><li><p>通配符</p><ul><li><ul><li>：匹配零个或多个字符</li></ul></li><li>？:匹配一个字符</li></ul></li><li><p>输入/输出重定向</p><ul><li>&lt;：输入重定向</li><li><blockquote><p>：输出重定向</p></blockquote></li><li><blockquote><blockquote><p>：追加重定向</p></blockquote></blockquote></li></ul></li><li><p>管道符</p><ul><li>|:将前面命令的运行结果作为后面命令的输入条件</li></ul></li><li><p>作业控制</p><ul><li>Ctrl+Z：暂停进程</li><li>fg：恢复进程</li><li>bg：使进程在后台运行</li><li>Ctrl+C：终止进程</li></ul></li></ul><h3 id="shell中的编码规范"><a href="#shell中的编码规范" class="headerlink" title="shell中的编码规范"></a>shell中的编码规范</h3><ul><li><p>echo命令</p><ul><li>用于向窗口输出文本、字符串</li></ul></li><li><p>shell注释</p><ul><li>以#开头的行，只有单行注释</li></ul></li><li><p>变量</p><ul><li>局部变量</li><li>环境变量</li><li>shell变量</li></ul></li><li><p>数据类型</p><ul><li>字符创</li><li>shell数组</li></ul></li><li><p>shell基本运算符</p><ul><li>算术运算符</li><li>关系运算符</li><li>布尔运算符</li><li>字符串运算符</li></ul></li><li><p>shell流程控制</p><ul><li>if条件控制</li><li>for循环控制</li><li>while循环控制</li><li>until循环</li><li>case语句</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/posts/2.html"/>
      <url>/posts/2.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h1><h2 id="Java语法基础"><a href="#Java语法基础" class="headerlink" title="Java语法基础"></a>Java语法基础</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>标识符就是变量、常量、方法、枚举、类、接口等由程序员指定的名字。构成标识符的字母均有一定的规范，Java语言中标识符的命名规则如下</li><li>01.区分大小写：Myname与myname是两个不同的标识符。</li><li><ol start="2"><li>首字符，可以是下划线（_）或美元符或字母，但不能是数字。</li></ol></li><li><ol start="3"><li>除首字符外其他字符，可以是下划线（_）、美元符、字母和数字。</li></ol></li><li><ol start="4"><li>关键字不能作为标识符。</li></ol></li></ul><h3 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h3><ul><li><p>访问控制</p><ul><li>private    私有的</li><li>public    公共的</li><li>default    默认</li><li>protected    受保护的</li></ul></li><li><p>类、方法和变量修饰符</p><ul><li>abstract    声明抽象</li><li>class    类</li><li>extends    扩充,继承</li><li>final    最终值,不可改变的</li><li>implements    实现（接口）</li><li>interface    接口</li><li>native    本地，原生方法（非 Java 实现）</li><li>new    新,创建</li><li>static    静态</li><li>strictfp    严格,精准</li><li>synchronized    线程,同步</li><li>transient    短暂</li><li>volatile    易失</li></ul></li><li><p>程序控制语句</p><ul><li>break    跳出循环</li><li>case    定义一个值以供 switch 选择</li><li>continue    继续</li><li>do    运行</li><li>else    否则</li><li>for    循环</li><li>if    如果</li><li>instanceof    实例</li><li>return    返回</li><li>switch    根据值选择执行</li><li>while    循环</li></ul></li><li><p>错误处理</p><ul><li>assert    断言表达式是否为真</li><li>catch    捕捉异常</li><li>finally    有没有异常都执行</li><li>throw    抛出一个异常对象</li><li>throws    声明一个异常可能被抛出</li><li>try    捕获异常</li></ul></li><li><p>包相关</p><ul><li>import     引入</li><li>package    包</li></ul></li><li><p>基本类型</p><ul><li>boolean    布尔型</li><li>char    字符型</li><li>double    双精度浮点</li><li>byte    字节型</li><li>float    单精度浮点</li><li>int    整型</li><li>short    短整型</li><li>long    长整型</li></ul></li><li><p>变量引用</p><ul><li>super  父类，超类</li><li>void    无返回值</li><li>this    本类</li></ul></li></ul><h3 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h3><ul><li>goto    是关键字，但不能使用</li><li>const    是关键字，但不能使用</li></ul><h3 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h3><ul><li>在Java源代码中，有一些字符被用作分隔，称为分隔符。分隔符主要有：分号（;）、左右大括号<br>（{}）和空白。</li></ul><h3 id="Java的常量与变量"><a href="#Java的常量与变量" class="headerlink" title="Java的常量与变量"></a>Java的常量与变量</h3><ul><li><p>Java常量</p><ul><li><p>常量在声明的同时需要赋予一个初始值，声明格式：final 数据类型 变量名 = 初始值;</p></li><li><p>使用final关键字来修饰常量，声明方式和变量类似，通常用大写字母表示常量</p></li><li><p>字符串常量包含在两个引号之间的字符序列，和字符变量都可以包含任何Unicode字符</p></li><li><p>定义变量的时候，如果加上final修饰符，这个变量就变成了常量</p></li><li><p>Java 的 null 不是关键字，类似于 true 和 false，它是一个字面常量，不允许作为标识符使用</p></li><li><p>分类</p><ul><li><p>静态常量</p><ul><li>在final 之前使用public static修饰，用来替代保留字const。</li><li>public static修饰的常量作用域是全局的，不需<br>要创建对象就可以访问它，在类外部访问形式：HelloWorld. PI   （类名.常量名）</li></ul></li><li><p>成员常量</p></li><li><p>局部常量</p></li></ul></li></ul></li><li><p>Java变量</p><ul><li><p>类变量（静态变量）：独立于方法之外的变量，用 static 修饰。</p><ul><li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li><li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li><li>静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。</li><li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li><li>静态变量在第一次被访问时创建，在程序结束时销毁。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li><li>默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：ClassName.VariableName的方式访问。</li><li>类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul></li><li><p>实例（成员）变量：独立于方法之外的变量，不过没有 static 修饰。成员变量是在类体中，而在方法之外，作用域是整个类，如果没有赋初始值，系统使用默认值</p><ul><li>成员变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>成员变量在对象创建的时候创建，在对象被销毁的时候销毁；</li><li>成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li>访问修饰符可以修饰实例变量；</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li><li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObjectReference.VariableName。</li></ul></li><li><p>局部变量：是在方法或if、for和while等代码块中声明的变量。</p><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li>访问修饰符不能用于局部变量；</li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在栈上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul></li></ul></li></ul><h2 id="Java编码规范"><a href="#Java编码规范" class="headerlink" title="Java编码规范"></a>Java编码规范</h2><h3 id="命名规范（驼峰命名）"><a href="#命名规范（驼峰命名）" class="headerlink" title="命名规范（驼峰命名）"></a>命名规范（驼峰命名）</h3><ul><li><p>小驼峰命名</p><ul><li>小驼峰法就是第一个单词是全部小写，后面的单词首字母大写</li></ul></li><li><p>大驼峰命名</p><ul><li>大驼峰法是第一个单词的首字母也大写</li></ul></li><li><p>除了包和常量外，Java编码规范命名方法采用驼峰法</p><ul><li>包名：包名是全小写字母，中间可以由点分隔开。作为命名空间，包名应该具有唯一性</li><li>常量名：全大写，如果是由多个单词构成，可以用下划线隔开如YEAR和WEEK_OF_MONTH。</li><li>类和接口名：采用大驼峰法</li><li>文件名：采用大驼峰法</li><li>变量：采用小驼峰法</li><li>方法名：采用小驼峰法</li></ul></li></ul><h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><ul><li><p>文档注释：/**    */</p><ul><li>文档注释就是指这种注释内容能够生成API帮助文档，JDK中javadoc命令能够提取这些注释信息并生成HTML文件。文档注释主要对类（或接口）、实例变量、静态变量、实例方法和静态方法等进行注释。</li><li>生成文档后，会生成很多HTML文件，其中的index.html文件是文档的入口</li></ul></li><li><p>多行注释</p><ul><li>/*   */</li></ul></li><li><p>单行注释</p><ul><li>//</li></ul></li></ul><h3 id="代码排版"><a href="#代码排版" class="headerlink" title="代码排版"></a>代码排版</h3><ul><li><p>空行用以将逻辑相关的代码段分隔开，以提高可读性，空行使用规范：</p><ul><li><ol><li>类声明和接口声明之间保留两个空行</li></ol></li><li><ol start="2"><li>两个方法之间保留一个空行</li></ol></li><li><ol start="3"><li>方法的第一条语句之前保留一个空行</li></ol></li><li><ol start="4"><li>代码注释（尾端注释外）之前保留一个空行</li></ol></li><li><ol start="5"><li>一个方法内的两个逻辑段之间</li></ol></li></ul></li><li><p>代码中的有些位置是需要有空格的，空格的规范：</p><ul><li><ol><li>赋值符号“=”前后各有一个空格</li></ol></li><li><ol start="2"><li>所有的二元运算符都应该使用空格与操作数分开</li></ol></li><li><ol start="3"><li>一元操作符：负号“-”、自增“++”和自减“–”等，它们与操作数之间没有空格</li></ol></li><li><ol start="4"><li>小左括号“(”之后，小右括号“)”之前不应有空格</li></ol></li><li><ol start="5"><li>大左括号“{”之前有一个空格</li></ol></li><li><ol start="6"><li>方法参数列表小左括号“(”之前没有空格，小右括号“)”之后有一个空格，参数列表中参数逗号“,”之后也有一个空格。</li></ol></li><li><ol start="7"><li>关键字之后紧跟着小左括号“(”，关键字之后应该有一个空格</li></ol></li></ul></li><li><p>缩进的规范</p><ul><li><ol><li>在方法、Lambda、控制语句等包含大括号“{}”的代码块中，代码块的内容相对于首行缩进一个级别（4个空格）</li></ol></li><li><ol start="2"><li>如果是if语句中条件表达式的断行，那么新的一行应该相对于上一行缩进两个级别（8个空<br>格），再往后的断行要与第一次的断行对齐</li></ol></li></ul></li><li><p>一行代码的长度应尽量不要超过80个字符，如果超过则需断行，断行的规范</p><ul><li><ol><li>在一个逗号后面断开。</li></ol></li><li><ol start="2"><li>在一个操作符前面断开，要选择较高级别的运算符（而非较低级别的运算符）断开。</li></ol></li><li><ol start="3"><li>新的一行应该相对于上一行缩进两个级别（8个空格）。</li></ol></li></ul></li><li><p>其他规范</p><ul><li><ol><li>在声明变量或常量时推荐一行一个声明</li></ol></li><li><ol start="2"><li>左大括号“{”位于声明语句同行的末尾。右大括号“}”另起一行，与相应的声明语句对齐，除非<br>是一个空语句，右大括号“}”应紧跟在左大括号“{”之后</li></ol></li><li><ol start="3"><li>每行至多包含一条语句</li></ol></li><li><ol start="4"><li>虽然Java语言允许if、for等控制语句只有一行代码情况下，省略左右两个大括号，但是编码规范并不推荐这样使用</li></ol></li></ul></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li><p>数值类型</p><ul><li><p>整数类型（默认int）</p><ul><li>byte：8位，默认是0</li><li>short：2个字节，默认是0</li><li>int：4个字节，默认是0</li><li>long：8个字节，默认是0L</li></ul></li><li><p>浮点数类型（默认double）</p><ul><li>float：4个字节，默认是0.0f</li><li>double：8个字节,默认是0.0d</li></ul></li><li><p>字符类型</p><ul><li>char:2个字节，范围\u0000(0)~\uffff(65535),默认值是’u0000’</li><li>字符常量必须用单引号括起来的单个字<br>符</li></ul></li></ul></li><li><p>布尔类型</p><ul><li>boolean：true or  false,默认是false</li></ul></li><li><p>转义字符</p><ul><li>\n:换行（0x0a）</li><li>\r：回车（0x0d）</li><li>\t    制表符</li><li>\f：换页符（0x0c）</li><li>\b    退格 (0x08)</li><li>\0    空字符 (0x0)</li><li>\s    空格 (0x20)</li><li>"    双引号</li><li>'    单引号</li><li>\    反斜杠</li><li>\ddd    八进制字符 (ddd)</li><li>\uxxxx    16进制Unicode字符 (xxxx)</li></ul></li><li><p>数据类型转换</p><ul><li><p>自动类型转换</p><ul><li>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。<br>转换从低级到高级：byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double </li><li>规则：1. 不能对boolean类型进行类型转换。</li></ul></li></ul></li></ul><ol start="2"><li><p>不能把对象类型转换成不相关类的对象。</p></li><li><p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p></li><li><p>转换过程中可能导致溢出或损失精度</p></li><li><p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入</p><ul><li><p>强制类型转换</p><ul><li><ol><li>条件是转换的数据类型必须是兼容的。</li></ol></li><li><ol start="2"><li>格式：(type)value type是要强制类型转换后的数据类型 </li></ol></li></ul></li><li><p>隐含强制类型转换</p><ul><li>1、 整数的默认类型是 int。</li><li><ol start="2"><li>小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。</li></ol></li></ul></li></ul></li></ol><ul><li><p>数字表示方式</p><ul><li><p>进制数字表示方式</p><ul><li>二进制数：以 0b 或0B为前缀，注意0是阿拉伯数字，不要误认为是英文字母o。</li><li>八进制数：以0为前缀，注意0是阿拉伯数字。</li><li>十六进制数：以 0x 或0X为前缀，注意0是阿拉伯数字</li></ul></li><li><p>指数表示</p><ul><li>如果采用十进制表示指数，需要使用大写或小写的e表示幂，e2表示10的2次方。</li></ul></li></ul></li></ul><h3 id="引用数据类型（String）"><a href="#引用数据类型（String）" class="headerlink" title="引用数据类型（String）"></a>引用数据类型（String）</h3><ul><li><p>引用数据类型变量中保持的是指向对象的内存地址（引用数据类型在使用之前一定要：声明和初始化）默认值是null</p></li><li><p>类</p></li><li><p>接口</p></li><li><p>数组</p><ul><li>元素数据类型[] 数组变量名;   推荐使用这种声明方式</li></ul></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ul><li><p>一元运算</p><ul><li>-（取反）、++（自增）、–（自减）</li><li>前缀自增自减法(++a,–a): 先进行自增或者自减运算，再进行表达式运算。</li><li>后缀自增自减法(a++,a–): 先进行表达式运算，再进行自增或者自减运算 </li></ul></li><li><p>二元运算</p><ul><li>+、-、*、/、%</li></ul></li></ul><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul><li>&amp;（位与）、|（位或）、~（位反）、^(位异或)、&lt;&lt;（左移）、&gt;&gt;（有符号右移）、&gt;&gt;&gt;（无符号右移）、&amp;=（位与等于）、|=（位或等于）、^=（位异或等于）、&lt;&lt;=（左移等于）、&gt;&gt;=（右移等于）、&gt;&gt;&gt;=（右移等于）</li></ul><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul><li>==、!=、&gt;、&lt;、&gt;=、&lt;=</li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li>!（逻辑非）、&amp;（逻辑与）、|（逻辑或）、&amp;&amp;（短路与）、||（短路或）</li></ul><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul><li><p>算术赋值运算符</p><ul><li>+=、-=、*=、/=、%=</li></ul></li></ul><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><ul><li><p>三元运算符 (?:)</p><ul><li>variable x = (expression) ? value if true : value if false</li><li>三元运算符（? :）。例如x?y:z;，其中x、y和z都为表达式。</li></ul></li><li><p>instanceof 运算符</p><ul><li>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）</li><li>instanceof运算符使用格式:( Object reference variable ) instanceof  (class/interface type)</li></ul></li><li><p>小括号。起到改变表达式运算顺序的作用，它的优先级最高。</p></li><li><p>中括号。数组下标。</p></li><li><p>引用号（.）。对象调用实例变量或实例方法的操作符，也是类调用静态变量或静态方法的操作符。</p></li><li><p>赋值号（=）。赋值是用等号运算符（=）进行的。</p></li><li><p>new。对象内存分配运算符。</p></li><li><p>箭头（-&gt;）。Java 8新增加的，用来声明Lambda表达式。</p></li><li><p>双冒号（::）。Java 8新增加的，用于Lambda表达式中方法的引用。</p></li></ul><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="分支（条件）语句"><a href="#分支（条件）语句" class="headerlink" title="分支（条件）语句"></a>分支（条件）语句</h3><ul><li><p>if语句</p><ul><li><p>if语句</p><ul><li>if(布尔表达式)<br>{<br>//如果布尔表达式为true将执行的语句<br>}</li><li>如果布尔表达式的值为 true，则执行 if 语句中的代码块，否则执行 if 语句块后面的代码。</li></ul></li><li><p>if…else语句</p><ul><li>if(布尔表达式){<br>//如果布尔表达式的值为true<br>}else{<br>//如果布尔表达式的值为false<br>}</li><li>if 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。</li></ul></li><li><p>if…else if…else 语句</p><ul><li>if(布尔表达式 1){<br>//如果布尔表达式 1的值为true执行代码<br>}else if(布尔表达式 2){<br>//如果布尔表达式 2的值为true执行代码<br>}else if(布尔表达式 3){<br>//如果布尔表达式 3的值为true执行代码<br>}else {<br>//如果以上布尔表达式都不为true执行代码<br>}</li><li>if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。</li><li>if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。</li><li>一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。</li></ul></li></ul></li><li><p>switch case 语句</p><ul><li><p>switch(expression){<br>case value1:<br> //语句<br> break; //可选<br>case value2:<br> //语句<br> break; //可选<br>//你可以有任意数量的case语句<br>default : //可选<br> //语句<br>}</p></li><li><p>规则</p><ul><li>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</li><li>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</li><li>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li><li>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</li><li>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</li><li>switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</li></ul></li><li><p>switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。</p></li></ul></li></ul><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><ul><li><p>while 循环</p><ul><li>while( 布尔表达式 ) {<br> //循环内容<br>}</li><li>只要布尔表达式为 true，循环就会一直执行下去</li><li>如果循环体中需要循环变量，就必须在while语句之前对循环变量进行初始化</li></ul></li><li><p>do…while 循环</p><ul><li>do {<br> //代码语句<br>}while(布尔表达式);</li><li>对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。</li><li>布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。</li></ul></li><li><p>for 循环</p><ul><li>for(初始化; 布尔表达式; 更新) {<br>//代码语句<br>}</li><li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</li><li>然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</li><li>执行一次循环后，更新循环控制变量。</li><li>再次检测布尔表达式。循环执行上面的过程。</li></ul></li><li><p>Java 增强 for 循环–for-each语句</p><ul><li>Java5 引入了一种主要用于数组的增强型 for 循环。遍历集合使用for-each比较方便</li><li>for(声明语句 : 表达式)<br>{<br>//代码句子<br>}</li><li>声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</li><li>表达式：表达式是要访问的数组名，或者是返回值为数组的方法。</li></ul></li></ul><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><ul><li><p>break语句</p><ul><li>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</li><li>break 跳出最里层的循环，并且继续执行该循环下面的语句。</li><li>break还可以配合标签使用，多层循环的时候想要跳出外循环，可以为外循环添加一个标签，注意在定义标签的时候后面跟一个冒号，程序会跳转出标签所指定的循环</li></ul></li><li><p>continue语句</p><ul><li>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</li><li>在 for 循环中，continue 语句使程序立即跳转到更新语句。</li><li>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。</li><li>默认情况下，continue只会跳出最近的内循环，可以为外循环添加一个标签，continue语句后面指定这个标签，这样当条件满足执行continue语句时，程序就会跳转出外循环。</li></ul></li><li><p>return语句</p></li><li><p>throw语句</p></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><ul><li><p>声明语法：元素数据类型[] 数组变量名;</p></li><li><p>数组初始化</p><ul><li><p>静态初始化</p><ul><li>将数组的元素放到大括号中，元素之间用逗号（,）分隔</li></ul></li><li><p>动态初始化</p><ul><li>动态初始化使用new运算符分配指定长度的内存空间，</li><li>语法： new 元素数据类型[数组长度] ;</li></ul></li></ul></li></ul><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ul><li><p>声明语法：元素数据类型[][] 数组变量名;</p></li><li><p>二维数组初始化</p><ul><li><p>静态初始化</p><ul><li>int intArray[][] = { { 1, 2, 3 }, { 11, 12, 13 }, { 21, 22, 23 }, { 31, 32, 33 } };</li></ul></li><li><p>动态初始化</p><ul><li>new 元素数据类型[高维数组长度] [低维数组长度] ;</li></ul></li></ul></li></ul><h3 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h3><ul><li><p>高维数组元素个数确定，但是低维数组元素个数不同</p></li><li><p>动态初始化不规则数组比较麻烦，初始化4×3二维数组，不能使用new int[4][3]语句，而是先初始化高维数组，然后再分别逐个初始化低维数组</p><ul><li>int intArray[][] = new int[4][]; //先初始化高维数组为4<br>//逐一初始化低维数组<br>intArray[0] = new int[2];<br>intArray[1] = new int[1];<br>intArray[2] = new int[3];<br>intArray[3] = new int[3];</li></ul></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h3><ul><li><p>含义</p><ul><li>Java中的字符串是由双引号括起来的多个字符，Java中的字符采用Unicode编码</li><li>“” 空字符串不是null，空字符串是有分配内存空间的，而null是没有分配内存空间的。</li><li>获得字符串长度方法是length()</li></ul></li><li><p>String（不可变字符串），属于java.lang包，创建String对象可以通过构造方法实现，常用的构造方法</p><ul><li>String()：使用空字符串创建并初始化一个新的String对象。</li><li>String(String original)：使用另外一个字符串创建并初始化一个新的 String 对象。</li><li>String(StringBuffer buffer)：使用可变字符串对象（StringBuffer）创建并初始化一个新的String对象</li><li>String(StringBuilder builder)：使用可变字符串对象（StringBuilder）创建并初始化一个新的String 对象</li><li>String(byte[] bytes)：使用平台的默认字符集解码指定的byte数组，通过byte数组创建并初始化一个新的 String 对象</li><li>String(char[] value)：通过字符数组创建并初始化一个新的 String 对象。</li><li>String(char[] value, int offset, int count)：通过字符数组的子数组创建并初始化一个新的 String 对象；offset参数是子数组第一个字符的索引，count参数指定子数组的长度</li></ul></li><li><p>可变字符串（字符串缓冲区）</p><ul><li><p>StringBuffer（可变字符串）</p><ul><li>StringBuffer是线程安全的，它的方法是支持线程同步 ，线程同步会操作串行顺序执行，在单线程环境下会影响效率。StringBuilder是StringBuffer单线程版本，Java 5之后发布的，它不是线程安全的，但它的执行效率很高。</li></ul></li><li><p>StringBuilder（可变字符串）</p><ul><li>StringBuilder()：创建字符串内容是空的StringBuilder对象，初始容量默认为16个字符。</li><li>StringBuilder(CharSequence seq)：指定CharSequence字符串创建StringBuilder对象。CharSequence接口类型，它的实现类有：String、StringBuffer和StringBuilder等，所以参数seq可以是String、StringBuffer和StringBuilder等类型。</li><li>StringBuilder(int capacity)：创建字符串内容是空的StringBuilder对象，初始容量由参数capacity指定的。</li><li>StringBuilder(String str)：指定String字符串创建StringBuilder对象。</li><li>StringBuilder在提供了很多修改字符串缓冲区的方法，追加、插入、删除和替换等</li></ul></li><li><p>字符串追加</p><ul><li>字符串追加方法是append，append有很多重载方法，可以追加任何类型数据，它的返回值还是StringBuilder</li></ul></li><li><p>字符串插入、删除、替换</p><ul><li>StringBuilder insert(int offset, String str)：在字符串缓冲区中索引为offset的字符位置之前插入str，<br>insert有很多重载方法，可以插入任何类型数据</li><li>StringBuffer delete(int start, int end)：在字符串缓冲区中删除子字符串，要删除的子字符串从指定<br>索引start开始直到索引end - 1处的字符。start和end两个参数与substring(int beginIndex, int<br>endIndex)方法中的两个参数含义一样</li><li>StringBuffer replace(int start, int end, String str)字符串缓冲区中用str替换子字符串，子字符串从指<br>定索引start开始直到索引end - 1处的字符。start和end同delete(int start, int end)方法</li></ul></li></ul></li></ul><h3 id="字符串池"><a href="#字符串池" class="headerlink" title="字符串池"></a>字符串池</h3><ul><li>Java中的不可变字符串String常量，采用字符串池（String Pool）管理技术，字符串池是<br>一种字符串驻留技术</li><li>2个字符串常量赋值同一个值，他们是相同的引用，指向同一个对象</li><li>new关键字创建2个字符串对象，是不同的引用，指向不同的对象</li></ul><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><ul><li><p>字符串拼接</p><ul><li><p>拼接是会产生一个新的对象。</p></li><li><p>String字符串拼接可以使用+运算符或String的concat(String str)方法。</p><ul><li>concat方法定义：public String concat(String str)</li><li>Java中所有对象都有一个toString()方法，该方法可以将对象转换为字符串，拼接过程会调用<br>该对象的toString()方法，将该对象转换为字符串后再进行拼接。</li><li>String的charAt(int index)方法可以返回索引index所在位置的字符</li></ul></li><li><p>+运算符优势是可以连接任何类型数据拼接成为字符串，而concat方法只能拼接String类型字符串。</p></li></ul></li><li><p>字符串查找</p><ul><li><p>indexOf方法</p><ul><li>int indexOf(int ch)：从前往后搜索字符ch，返回第一次找到字符ch所在处的索引。</li><li>int indexOf(int ch, int fromIndex)：从指定的索引开始从前往后搜索字符ch，返回第一次找到字符ch所在处的索引。</li><li>int indexOf(String str)：从前往后搜索字符串str，返回第一次找到字符串所在处的索引。</li><li>int indexOf(String str, int fromIndex)：从指定的索引开始从前往后搜索字符串str，返回第一次找到字符串所在处的索引。</li></ul></li><li><p>lastIndexOf方法</p><ul><li>int lastIndexOf(int ch)：从后往前搜索字符ch，返回第一次找到字符ch所在处的索引。</li><li>int lastIndexOf(int ch, int fromIndex)：从指定的索引开始从后往前搜索字符ch，返回第一次找到字符ch所在处的索引。</li><li>int lastIndexOf(String str)：从后往前搜索字符串str，返回第一次找到字符串所在处的索引。</li><li>int lastIndexOf(String str, int fromIndex)：从指定的索引开始从后往前搜索字符串str，返回第一次找到字符串所在处的索引</li></ul></li></ul></li><li><p>字符串比较</p><ul><li><ol><li>比较相等，String提供的比较字符串相等的方法：</li></ol><ul><li>boolean equals(Object anObject)：比较两个字符串中内容是否相等。</li><li>boolean equalsIgnoreCase(String anotherString)：类似equals方法，只是忽略大小写。</li></ul></li><li><ol start="2"><li>比较大小，有时不仅需要知道是否相等，还要知道大小，String提供的比较大小的方法：</li></ol><ul><li>int compareTo(String anotherString)：按字典顺序比较两个字符串。如果参数字符串等于此字符串，则返回值 0；如果此字符串小于字符串参数，则返回一个小于 0 的值；如果此字符串大于字符串参数，则返回一个大于 0 的值。</li><li>int compareToIgnoreCase(String str)：类似compareTo，只是忽略大小写。</li></ul></li><li><ol start="3"><li>比较前缀和后缀</li></ol><ul><li>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束。</li><li>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始。</li></ul></li></ul></li><li><p>字符串截取</p><ul><li>String substring(int beginIndex)：从指定索引beginIndex开始截取一直到字符串结束的子字符串</li><li>String substring(int beginIndex, int endIndex)：从指定索引beginIndex开始截取直到索引endIndex -1处的字符，注意包括索引为beginIndex处的字符，但不包括索引为endIndex处的字符</li><li>String还提供了字符串分割方法，split(“ “)方法，参数是分割字符串，返回值String[]</li></ul></li></ul><h3 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h3><ul><li><p>Java8在线api文档地址：<a href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a></p></li><li><p>文档页面中各部分的含义</p><ul><li>类和接口中，斜文字体显示是接口，正常字体才是类</li><li>“字段摘要”描述了类中的实例变量和静态变量</li><li>“构造方法摘要”描述了类中所有构造方法</li><li>“方法摘要”描述了类中所有方法</li></ul></li><li><p>查询API的一般流程：找包→找类或接口→查看类或接口→找方法或变量</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客与博主</title>
      <link href="/posts/1.html"/>
      <url>/posts/1.html</url>
      
        <content type="html"><![CDATA[<p>相遇皆是缘分</p><h3 id="为什么建博客？"><a href="#为什么建博客？" class="headerlink" title="为什么建博客？"></a>为什么建博客？</h3><p>想拥有一个自己的博客，好进行装逼!</p><h3 id="展望博客"><a href="#展望博客" class="headerlink" title="展望博客"></a>展望博客</h3><p>将一些自己搜集到的资料或学习到的东西整理成博客，上传上来，方便查阅。</p><h3 id="关于博主"><a href="#关于博主" class="headerlink" title="关于博主"></a>关于博主</h3><p>我取名叫从未，这是源于一句话，你喜欢过我吗？– 从未 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> 《自由与爱情》---作者:裴多菲​ 生命诚可贵​ 爱情价更高​ 若为自由故​ 二者皆可抛<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>溜溜球啦！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 想法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
